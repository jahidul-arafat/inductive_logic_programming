<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ILP Explorer | Inductive Logic Programming Research Platform</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Ambient Background -->
    <div class="ambient-bg">
        <div class="grid-overlay"></div>
        <div class="floating-symbols"></div>
    </div>

    <!-- Navigation -->
    <nav class="main-nav">
        <div class="nav-brand">
            <span class="brand-symbol">Œª</span>
            <span class="brand-text">ILP Explorer</span>
        </div>
        <div class="nav-links">
            <a href="#foundations" class="nav-link active" data-section="foundations">Foundations</a>
            <a href="#stories" class="nav-link" data-section="stories">Stories</a>
            <a href="#solvers" class="nav-link" data-section="solvers">Solvers</a>
            <a href="#systems" class="nav-link" data-section="systems">Systems</a>
            <a href="#playground" class="nav-link" data-section="playground">Playground</a>
            <a href="#research" class="nav-link" data-section="research">Research</a>
            <a href="#advanced-research" class="nav-link" data-section="advanced-research">Advanced</a>
        </div>
        <div class="nav-level">
            <span class="level-label">Complexity</span>
            <input type="range" min="1" max="5" value="1" class="level-slider" id="complexitySlider">
            <span class="level-indicator" id="levelIndicator">Beginner</span>
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="hero">
        <div class="hero-content">
            <div class="hero-badge">ELLIS Institute Finland ‚Ä¢ PhD Research</div>
            <h1 class="hero-title">
                <span class="title-line">Inductive Logic</span>
                <span class="title-line accent">Programming</span>
            </h1>
            <p class="hero-subtitle">
                An interactive exploration of learning logical rules from data using automated reasoning techniques
            </p>
            <div class="hero-stats">
                <div class="stat">
                    <span class="stat-value">30+</span>
                    <span class="stat-label">Years of Research</span>
                </div>
                <div class="stat">
                    <span class="stat-value">SAT/ASP/SMT</span>
                    <span class="stat-label">Solver Integration</span>
                </div>
                <div class="stat">
                    <span class="stat-value">‚àû</span>
                    <span class="stat-label">Hypothesis Space</span>
                </div>
            </div>
            <div class="hero-actions">
                <button class="btn btn-primary" onclick="scrollToSection('foundations')">
                    Begin Exploration
                    <span class="btn-arrow">‚Üí</span>
                </button>
                <button class="btn btn-secondary" onclick="scrollToSection('playground')">
                    Try Playground
                </button>
            </div>
        </div>
        <div class="hero-visual">
            <div class="logic-tree" id="heroTree"></div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        
        <!-- Section 1: Foundations -->
        <section id="foundations" class="section">
            <div class="section-header">
                <span class="section-number">01</span>
                <h2 class="section-title">Foundations of ILP</h2>
                <p class="section-desc">Understanding the theoretical underpinnings of learning logic programs from examples</p>
            </div>

            <!-- What is ILP -->
            <div class="content-block" data-level="1">
                <div class="block-header">
                    <h3>What is Inductive Logic Programming?</h3>
                    <span class="complexity-badge beginner">Beginner</span>
                </div>
                <div class="block-content">
                    <div class="explanation-simple">
                        <div class="analogy-card">
                            <div class="analogy-icon">üßí</div>
                            <div class="analogy-text">
                                <strong>Think of it like this:</strong> When you were young, nobody gave you a rulebook for everything. 
                                You learned by watching examples! ILP teaches computers to do the same thing ‚Äî figure out rules by looking at examples.
                            </div>
                        </div>
                    </div>
                    
                    <div class="visual-demo" id="simpleRuleDemo">
                        <h4>Interactive Demo: Learning a Rule</h4>
                        <div class="demo-container">
                            <div class="examples-panel">
                                <div class="examples-positive">
                                    <h5>‚úÖ Positive Examples</h5>
                                    <div class="example-list" id="positiveExamples">
                                        <div class="example-item" data-value="2">2</div>
                                        <div class="example-item" data-value="4">4</div>
                                        <div class="example-item" data-value="6">6</div>
                                        <div class="example-item" data-value="8">8</div>
                                    </div>
                                    <button class="btn-small" onclick="addPositiveExample()">+ Add Example</button>
                                </div>
                                <div class="examples-negative">
                                    <h5>‚ùå Negative Examples</h5>
                                    <div class="example-list" id="negativeExamples">
                                        <div class="example-item" data-value="1">1</div>
                                        <div class="example-item" data-value="3">3</div>
                                        <div class="example-item" data-value="5">5</div>
                                        <div class="example-item" data-value="7">7</div>
                                    </div>
                                    <button class="btn-small" onclick="addNegativeExample()">+ Add Example</button>
                                </div>
                            </div>
                            <div class="inference-arrow">
                                <div class="arrow-line"></div>
                                <div class="arrow-label">ILP Learns</div>
                                <div class="arrow-head">‚ñ∂</div>
                            </div>
                            <div class="rule-panel">
                                <h5>üìú Learned Rule</h5>
                                <div class="learned-rule" id="learnedRule">
                                    <code>positive(X) :- even(X)</code>
                                </div>
                                <div class="rule-explanation">
                                    "X is positive if X is an even number"
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Formal Definition -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>Formal Definition</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="formal-definition">
                        <div class="definition-card">
                            <h4>The ILP Problem</h4>
                            <div class="math-block">
                                <p><strong>Given:</strong></p>
                                <ul>
                                    <li>Background knowledge <em>B</em> (a logic program)</li>
                                    <li>Positive examples <em>E<sup>+</sup></em> (ground atoms to be entailed)</li>
                                    <li>Negative examples <em>E<sup>-</sup></em> (ground atoms not to be entailed)</li>
                                </ul>
                                <p><strong>Find:</strong> A hypothesis <em>H</em> such that:</p>
                                <div class="formula">
                                    <div class="formula-line">B ‚à™ H ‚ä® E<sup>+</sup> <span class="formula-label">(completeness)</span></div>
                                    <div class="formula-line">B ‚à™ H ‚ä≠ E<sup>-</sup> <span class="formula-label">(consistency)</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Architecture Diagram -->
                    <div class="architecture-diagram">
                        <h4>ILP System Architecture</h4>
                        <div class="diagram-container" id="ilpArchitecture">
                            <svg viewBox="0 0 800 400" class="arch-svg">
                                <!-- Input Layer -->
                                <g class="layer input-layer" transform="translate(50, 50)">
                                    <rect class="node input-node" x="0" y="0" width="120" height="60" rx="8"/>
                                    <text x="60" y="35" class="node-text">E‚Å∫ Examples</text>
                                </g>
                                <g class="layer input-layer" transform="translate(50, 130)">
                                    <rect class="node input-node" x="0" y="0" width="120" height="60" rx="8"/>
                                    <text x="60" y="35" class="node-text">E‚Åª Examples</text>
                                </g>
                                <g class="layer input-layer" transform="translate(50, 210)">
                                    <rect class="node input-node" x="0" y="0" width="120" height="60" rx="8"/>
                                    <text x="60" y="35" class="node-text">Background B</text>
                                </g>

                                <!-- Processing Layer -->
                                <g class="layer process-layer" transform="translate(280, 100)">
                                    <rect class="node process-node" x="0" y="0" width="160" height="120" rx="8"/>
                                    <text x="80" y="40" class="node-text">Hypothesis</text>
                                    <text x="80" y="65" class="node-text">Search</text>
                                    <text x="80" y="95" class="node-text-small">Generate & Test</text>
                                </g>

                                <!-- Solver Layer -->
                                <g class="layer solver-layer" transform="translate(280, 280)">
                                    <rect class="node solver-node" x="0" y="0" width="160" height="60" rx="8"/>
                                    <text x="80" y="35" class="node-text">SAT/ASP/SMT</text>
                                </g>

                                <!-- Output Layer -->
                                <g class="layer output-layer" transform="translate(550, 130)">
                                    <rect class="node output-node" x="0" y="0" width="140" height="80" rx="8"/>
                                    <text x="70" y="35" class="node-text">Hypothesis H</text>
                                    <text x="70" y="60" class="node-text-small">Learned Rules</text>
                                </g>

                                <!-- Arrows -->
                                <g class="arrows">
                                    <path class="arrow" d="M170,80 Q220,110 280,140" marker-end="url(#arrowhead)"/>
                                    <path class="arrow" d="M170,160 L280,160" marker-end="url(#arrowhead)"/>
                                    <path class="arrow" d="M170,240 Q220,200 280,180" marker-end="url(#arrowhead)"/>
                                    <path class="arrow" d="M360,220 L360,280" marker-end="url(#arrowhead)"/>
                                    <path class="arrow" d="M360,280 L360,220" marker-end="url(#arrowhead)" transform="translate(0, 60)"/>
                                    <path class="arrow" d="M440,170 L550,170" marker-end="url(#arrowhead)"/>
                                </g>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--accent-primary)"/>
                                    </marker>
                                </defs>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Inductive vs Deductive -->
            <div class="content-block" data-level="1">
                <div class="block-header">
                    <h3>Inductive vs Deductive Reasoning</h3>
                    <span class="complexity-badge beginner">Beginner</span>
                </div>
                <div class="block-content">
                    <div class="comparison-container">
                        <div class="comparison-card deductive">
                            <div class="card-header">
                                <span class="card-icon">‚¨áÔ∏è</span>
                                <h4>Deductive (Top-Down)</h4>
                            </div>
                            <div class="card-body">
                                <div class="reasoning-flow">
                                    <div class="flow-step rule">
                                        <span class="step-label">Rule</span>
                                        <span class="step-content">All birds have feathers</span>
                                    </div>
                                    <div class="flow-arrow">‚Üì</div>
                                    <div class="flow-step fact">
                                        <span class="step-label">Fact</span>
                                        <span class="step-content">A penguin is a bird</span>
                                    </div>
                                    <div class="flow-arrow">‚Üì</div>
                                    <div class="flow-step conclusion">
                                        <span class="step-label">Conclusion</span>
                                        <span class="step-content">A penguin has feathers ‚úì</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="comparison-divider">
                            <span>VS</span>
                        </div>

                        <div class="comparison-card inductive">
                            <div class="card-header">
                                <span class="card-icon">‚¨ÜÔ∏è</span>
                                <h4>Inductive (Bottom-Up)</h4>
                            </div>
                            <div class="card-body">
                                <div class="reasoning-flow">
                                    <div class="flow-step examples">
                                        <span class="step-label">Examples</span>
                                        <span class="step-content">
                                            Sparrow has feathers<br>
                                            Eagle has feathers<br>
                                            Penguin has feathers
                                        </span>
                                    </div>
                                    <div class="flow-arrow">‚Üì</div>
                                    <div class="flow-step hypothesis">
                                        <span class="step-label">Hypothesis</span>
                                        <span class="step-content">"All birds have feathers!"</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Interactive Comparison -->
                    <div class="interactive-reasoning" id="reasoningDemo">
                        <h4>Try It Yourself!</h4>
                        <div class="reasoning-playground">
                            <div class="playground-input">
                                <label>Add observations:</label>
                                <input type="text" id="observationInput" placeholder="e.g., 'Swan is white'">
                                <button class="btn-small" onclick="addObservation()">Add</button>
                            </div>
                            <div class="observations-list" id="observationsList">
                                <div class="observation">Crow is black</div>
                                <div class="observation">Raven is black</div>
                                <div class="observation">Blackbird is black</div>
                            </div>
                            <button class="btn btn-primary" onclick="induceRule()">Induce Rule</button>
                            <div class="induced-rule" id="inducedRule">
                                <span class="rule-icon">üí°</span>
                                <span class="rule-text">Add observations and click "Induce Rule"</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- First-Order Logic Primer -->
            <div class="content-block" data-level="2">
                <div class="block-header">
                    <h3>First-Order Logic Primer</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="logic-primer">
                        <div class="primer-section">
                            <h4>Building Blocks</h4>
                            <div class="logic-elements">
                                <div class="element-card">
                                    <div class="element-symbol">c</div>
                                    <div class="element-name">Constants</div>
                                    <div class="element-example">alice, bob, 42</div>
                                </div>
                                <div class="element-card">
                                    <div class="element-symbol">X</div>
                                    <div class="element-name">Variables</div>
                                    <div class="element-example">X, Y, Person</div>
                                </div>
                                <div class="element-card">
                                    <div class="element-symbol">p()</div>
                                    <div class="element-name">Predicates</div>
                                    <div class="element-example">parent(X,Y), even(N)</div>
                                </div>
                                <div class="element-card">
                                    <div class="element-symbol">:-</div>
                                    <div class="element-name">Implication</div>
                                    <div class="element-example">head :- body</div>
                                </div>
                            </div>
                        </div>

                        <div class="primer-section">
                            <h4>Example: Family Relations</h4>
                            <div class="code-block">
                                <pre><code class="prolog">% Facts (Ground atoms)
parent(alice, bob).
parent(bob, charlie).
parent(bob, diana).

% Rule (Horn clause)
grandparent(X, Z) :- 
    parent(X, Y), 
    parent(Y, Z).

% Query
?- grandparent(alice, charlie).
% Answer: Yes!</code></pre>
                            </div>
                            <div class="code-visualization" id="familyTreeViz">
                                <!-- Will be populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hypothesis Space - PhD Level Deep Dive -->
            <div class="content-block" data-level="4">
                <div class="block-header">
                    <h3>Hypothesis Space & Language Bias</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="hypothesis-space-phd">
                        <!-- Introduction -->
                        <div class="space-intro">
                            <p>
                                The <strong>hypothesis space</strong> ‚Ñã is the set of all possible hypotheses (logic programs) 
                                that an ILP system can consider. Without constraints, this space is <em>infinite</em> and 
                                learning becomes undecidable. <strong>Language bias</strong> restricts ‚Ñã to make learning tractable.
                            </p>
                            <div class="key-definition">
                                <h5>Definition (Hypothesis Space)</h5>
                                <p>Given background knowledge B, examples E‚Å∫, E‚Åª, and language bias ‚Ñí:</p>
                                <div class="math-formula">
                                    ‚Ñã(‚Ñí) = {H | H is a logic program consistent with ‚Ñí}
                                </div>
                                <p>The learning task: Find H ‚àà ‚Ñã such that B ‚à™ H ‚ä® E‚Å∫ and B ‚à™ H ‚ä≠ e for all e ‚àà E‚Åª</p>
                            </div>
                        </div>

                        <!-- Generality Ordering & Lattice Structure -->
                        <div class="generality-section">
                            <h4>Generality Ordering (Œ∏-Subsumption)</h4>
                            <div class="subsumption-explanation">
                                <div class="definition-box">
                                    <h5>Definition (Œ∏-Subsumption)</h5>
                                    <p>Clause C‚ÇÅ <strong>Œ∏-subsumes</strong> clause C‚ÇÇ (written C‚ÇÅ ‚â§Œ∏ C‚ÇÇ) iff 
                                    there exists a substitution Œ∏ such that C‚ÇÅŒ∏ ‚äÜ C‚ÇÇ.</p>
                                    <p class="intuition">Intuitively: C‚ÇÅ is <em>more general</em> than C‚ÇÇ if C‚ÇÅ covers at least everything C‚ÇÇ covers.</p>
                                </div>
                                
                                <div class="subsumption-example">
                                    <h5>Example: Generality Hierarchy</h5>
                                    <div class="generality-chain">
                                        <div class="chain-item most-general">
                                            <code>gp(X,Y) ‚Üê true</code>
                                            <span class="label">Most General (‚ä§)</span>
                                            <span class="coverage">Covers everything</span>
                                        </div>
                                        <div class="chain-arrow">‚Üì more specific</div>
                                        <div class="chain-item">
                                            <code>gp(X,Y) ‚Üê parent(X,Z)</code>
                                            <span class="coverage">Covers all X with children</span>
                                        </div>
                                        <div class="chain-arrow">‚Üì more specific</div>
                                        <div class="chain-item">
                                            <code>gp(X,Y) ‚Üê parent(X,Z), parent(Z,Y)</code>
                                            <span class="coverage">Covers true grandparents</span>
                                        </div>
                                        <div class="chain-arrow">‚Üì more specific</div>
                                        <div class="chain-item">
                                            <code>gp(X,Y) ‚Üê parent(X,Z), parent(Z,Y), male(Z)</code>
                                            <span class="coverage">Only through male intermediate</span>
                                        </div>
                                        <div class="chain-arrow">‚Üì more specific</div>
                                        <div class="chain-item most-specific">
                                            <code>gp(ann,carol) ‚Üê parent(ann,bob), parent(bob,carol)</code>
                                            <span class="label">Most Specific (‚ä•)</span>
                                            <span class="coverage">Single ground instance</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="lattice-properties">
                                <h5>Lattice-Theoretic Properties</h5>
                                <div class="properties-grid">
                                    <div class="property-card">
                                        <h6>Reflexivity</h6>
                                        <p>C ‚â§Œ∏ C (identity substitution)</p>
                                    </div>
                                    <div class="property-card">
                                        <h6>Transitivity</h6>
                                        <p>C‚ÇÅ ‚â§Œ∏ C‚ÇÇ ‚àß C‚ÇÇ ‚â§Œ∏ C‚ÇÉ ‚Üí C‚ÇÅ ‚â§Œ∏ C‚ÇÉ</p>
                                    </div>
                                    <div class="property-card">
                                        <h6>Anti-symmetry*</h6>
                                        <p>C‚ÇÅ ‚â§Œ∏ C‚ÇÇ ‚àß C‚ÇÇ ‚â§Œ∏ C‚ÇÅ ‚Üí C‚ÇÅ ‚âà C‚ÇÇ</p>
                                        <span class="note">*Up to variable renaming</span>
                                    </div>
                                    <div class="property-card">
                                        <h6>Non-lattice</h6>
                                        <p>Œ∏-subsumption does NOT form a lattice in general (no unique LUB/GLB)</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Interactive Hypothesis Lattice Visualization -->
                        <div class="lattice-visualization-section">
                            <h4>Interactive Hypothesis Lattice Explorer</h4>
                            <p class="viz-intro">
                                Explore how language bias parameters affect the hypothesis space structure. 
                                The lattice shows hypotheses ordered by generality (most general at top).
                            </p>
                            
                            <div class="lattice-explorer" id="latticeExplorer">
                                <div class="explorer-controls">
                                    <div class="control-panel">
                                        <h5>Language Bias Parameters</h5>
                                        
                                        <div class="control-group">
                                            <label>Max Body Literals (k):</label>
                                            <input type="range" min="1" max="5" value="3" id="maxBodyLiterals">
                                            <span class="control-value" id="maxBodyValue">3</span>
                                            <span class="control-effect">|body(H)| ‚â§ k</span>
                                        </div>
                                        
                                        <div class="control-group">
                                            <label>Max Variables (v):</label>
                                            <input type="range" min="2" max="6" value="3" id="maxVarsSlider">
                                            <span class="control-value" id="maxVarsValue">3</span>
                                            <span class="control-effect">|vars(H)| ‚â§ v</span>
                                        </div>
                                        
                                        <div class="control-group">
                                            <label>Max Clauses (c):</label>
                                            <input type="range" min="1" max="3" value="1" id="maxClausesSlider">
                                            <span class="control-value" id="maxClausesValue">1</span>
                                            <span class="control-effect">|H| ‚â§ c clauses</span>
                                        </div>
                                        
                                        <div class="control-group checkbox-group">
                                            <label>
                                                <input type="checkbox" id="allowRecursionCheck">
                                                Allow Recursion
                                            </label>
                                            <span class="control-effect">head predicate in body</span>
                                        </div>
                                        
                                        <div class="control-group checkbox-group">
                                            <label>
                                                <input type="checkbox" id="allowInventionCheck">
                                                Allow Predicate Invention
                                            </label>
                                            <span class="control-effect">auxiliary predicates</span>
                                        </div>
                                    </div>
                                    
                                    <div class="available-predicates">
                                        <h5>Available Predicates (Œ£)</h5>
                                        <div class="predicate-list">
                                            <div class="pred-item" data-pred="parent">
                                                <code>parent/2</code>
                                                <span class="pred-type">BK</span>
                                            </div>
                                            <div class="pred-item" data-pred="male">
                                                <code>male/1</code>
                                                <span class="pred-type">BK</span>
                                            </div>
                                            <div class="pred-item" data-pred="female">
                                                <code>female/1</code>
                                                <span class="pred-type">BK</span>
                                            </div>
                                            <div class="pred-item target" data-pred="grandparent">
                                                <code>grandparent/2</code>
                                                <span class="pred-type">Target</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="lattice-canvas-container">
                                    <canvas id="latticeCanvas" width="800" height="500"></canvas>
                                    <div class="lattice-legend">
                                        <div class="legend-item"><span class="dot unexplored"></span> Unexplored</div>
                                        <div class="legend-item"><span class="dot too-general"></span> Too General</div>
                                        <div class="legend-item"><span class="dot too-specific"></span> Too Specific</div>
                                        <div class="legend-item"><span class="dot solution"></span> Solution</div>
                                        <div class="legend-item"><span class="dot pruned"></span> Pruned</div>
                                    </div>
                                </div>
                                
                                <div class="lattice-stats">
                                    <div class="stat-card">
                                        <span class="stat-number" id="totalHypotheses">125</span>
                                        <span class="stat-label">Total Hypotheses</span>
                                        <span class="stat-formula">|‚Ñã(‚Ñí)|</span>
                                    </div>
                                    <div class="stat-card">
                                        <span class="stat-number" id="latticeDepth">5</span>
                                        <span class="stat-label">Lattice Depth</span>
                                        <span class="stat-formula">max path length</span>
                                    </div>
                                    <div class="stat-card">
                                        <span class="stat-number" id="branchingFactor">4.2</span>
                                        <span class="stat-label">Avg Branching</span>
                                        <span class="stat-formula">specializations per node</span>
                                    </div>
                                    <div class="stat-card complexity">
                                        <span class="stat-number" id="searchComplexity">O(v! √ó p^k)</span>
                                        <span class="stat-label">Search Complexity</span>
                                        <span class="stat-formula">without symmetry breaking</span>
                                    </div>
                                </div>
                                
                                <div class="lattice-animation-controls">
                                    <button class="anim-btn" id="animateSearchBtn" onclick="animateLatticeSearch()">
                                        <span class="icon">‚ñ∂</span> Animate Search
                                    </button>
                                    <button class="anim-btn" id="pauseSearchBtn" onclick="pauseLatticeSearch()" style="display:none;">
                                        <span class="icon">‚è∏</span> Pause
                                    </button>
                                    <button class="anim-btn" onclick="resetLattice()">
                                        <span class="icon">‚Ü∫</span> Reset
                                    </button>
                                    <div class="search-strategy">
                                        <label>Search Strategy:</label>
                                        <select id="searchStrategySelect" onchange="updateSearchStrategy()">
                                            <option value="topdown">Top-Down (General‚ÜíSpecific)</option>
                                            <option value="bottomup">Bottom-Up (Specific‚ÜíGeneral)</option>
                                            <option value="bidirectional">Bidirectional</option>
                                            <option value="bestfirst">Best-First (Heuristic)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="search-trace" id="latticeSearchTrace">
                                <h5>Search Trace</h5>
                                <div class="trace-log" id="traceLog">
                                    <div class="trace-entry init">Initialize: ‚Ñã contains <span id="initSize">125</span> hypotheses</div>
                                </div>
                            </div>
                        </div>

                        <!-- Mode Declarations Deep Dive -->
                        <div class="mode-declarations-section">
                            <h4>Mode Declarations (ALEPH/Progol Style)</h4>
                            <p class="section-intro">
                                Mode declarations specify how predicates can appear in hypotheses. They define 
                                the <strong>syntactic bias</strong> that restricts the hypothesis space.
                            </p>
                            
                            <div class="mode-types">
                                <div class="mode-type-card">
                                    <h5>Head Mode Declaration (modeh)</h5>
                                    <div class="mode-syntax">
                                        <code>modeh(recall, predicate(arg‚ÇÅ, ..., arg‚Çô))</code>
                                    </div>
                                    <div class="mode-explanation">
                                        <p>Specifies how the target predicate appears in the <strong>head</strong> of learned clauses.</p>
                                        <ul>
                                            <li><strong>recall</strong>: Maximum times this mode can be used (1 = determinate, * = unlimited)</li>
                                            <li><strong>+type</strong>: Input variable (must be bound by head or earlier body literal)</li>
                                            <li><strong>-type</strong>: Output variable (bound by this literal)</li>
                                            <li><strong>#type</strong>: Constant of given type</li>
                                        </ul>
                                    </div>
                                    <div class="mode-example">
                                        <h6>Example:</h6>
                                        <pre class="code-block">modeh(1, grandparent(+person, -person))</pre>
                                        <p class="example-explanation">
                                            Learn one clause with grandparent/2 as head. First argument is input (bound), 
                                            second is output (to be determined).
                                        </p>
                                    </div>
                                </div>
                                
                                <div class="mode-type-card">
                                    <h5>Body Mode Declaration (modeb)</h5>
                                    <div class="mode-syntax">
                                        <code>modeb(recall, predicate(arg‚ÇÅ, ..., arg‚Çô))</code>
                                    </div>
                                    <div class="mode-explanation">
                                        <p>Specifies how predicates can appear in the <strong>body</strong> of learned clauses.</p>
                                    </div>
                                    <div class="mode-example">
                                        <h6>Example:</h6>
                                        <pre class="code-block">modeb(*, parent(+person, -person))
modeb(*, parent(-person, +person))
modeb(1, male(+person))
modeb(1, female(+person))</pre>
                                        <p class="example-explanation">
                                            parent/2 can be used multiple times with different argument modes.
                                            male/female can each appear at most once.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="determination-section">
                                <h5>Determination Declarations</h5>
                                <p>Determinations specify which body predicates can be used with which head predicates:</p>
                                <div class="determination-example">
                                    <pre class="code-block">determination(grandparent/2, parent/2).
determination(grandparent/2, male/1).
determination(grandparent/2, female/1).</pre>
                                    <p class="example-explanation">
                                        Only parent, male, and female can appear in bodies of grandparent rules.
                                    </p>
                                </div>
                            </div>
                            
                            <div class="mode-space-calculation">
                                <h5>Hypothesis Space Size Calculation</h5>
                                <div class="calculation-formula">
                                    <p>Given:</p>
                                    <ul>
                                        <li>p body predicates with average arity a</li>
                                        <li>v maximum variables</li>
                                        <li>k maximum body literals</li>
                                    </ul>
                                    <div class="formula-box">
                                        <span class="formula">|‚Ñã| ‚âà Œ£·µ¢‚Çå‚ÇÄ·µè (p √ó v^a)‚Å± = O((p √ó v^a)^k)</span>
                                    </div>
                                    <p class="formula-note">
                                        With symmetry: multiply by v! for variable permutations (see Symmetry Breaking story)
                                    </p>
                                </div>
                                
                                <div class="interactive-calculator">
                                    <h6>Space Size Calculator</h6>
                                    <div class="calc-inputs">
                                        <div class="calc-input">
                                            <label>Predicates (p):</label>
                                            <input type="number" id="calcPredicates" value="4" min="1" max="20">
                                        </div>
                                        <div class="calc-input">
                                            <label>Avg Arity (a):</label>
                                            <input type="number" id="calcArity" value="2" min="1" max="4">
                                        </div>
                                        <div class="calc-input">
                                            <label>Max Vars (v):</label>
                                            <input type="number" id="calcVars" value="3" min="2" max="8">
                                        </div>
                                        <div class="calc-input">
                                            <label>Max Body (k):</label>
                                            <input type="number" id="calcBody" value="3" min="1" max="6">
                                        </div>
                                    </div>
                                    <button class="calc-btn" onclick="calculateSpaceSize()">Calculate</button>
                                    <div class="calc-result">
                                        <span class="result-label">Estimated |‚Ñã|:</span>
                                        <span class="result-value" id="calcResult">~2.9 √ó 10‚Åµ</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Metarules Deep Dive -->
                        <div class="metarules-section">
                            <h4>Metarules (Meta-Interpretive Learning)</h4>
                            <p class="section-intro">
                                Metarules are <strong>higher-order Horn clauses</strong> that define the structure 
                                of learnable hypotheses. They are templates where predicate symbols are variables.
                            </p>
                            
                            <div class="metarule-formal">
                                <h5>Formal Definition</h5>
                                <div class="definition-box">
                                    <p>A <strong>metarule</strong> is a clause of the form:</p>
                                    <div class="math-formula">
                                        P(XÃÑ) ‚Üê Q‚ÇÅ(»≤‚ÇÅ), Q‚ÇÇ(»≤‚ÇÇ), ..., Q‚Çô(»≤‚Çô)
                                    </div>
                                    <p>where P, Q‚ÇÅ, ..., Q‚Çô are <em>second-order variables</em> (predicate variables) 
                                    and XÃÑ, »≤‚ÇÅ, ..., »≤‚Çô are first-order variable tuples.</p>
                                </div>
                            </div>
                            
                            <div class="metarule-catalog">
                                <h5>Standard Metarule Catalog</h5>
                                <div class="metarule-grid">
                                    <div class="metarule-card" data-metarule="identity">
                                        <div class="metarule-header">
                                            <span class="metarule-name">Identity</span>
                                            <span class="metarule-arity">Arity: 2</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(X,Y)</pre>
                                        <div class="metarule-description">
                                            <p>Direct predicate equivalence</p>
                                            <p class="example">Example: <code>gp(X,Y) ‚Üê ancestor(X,Y)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop">Non-recursive</span>
                                            <span class="prop">1 body literal</span>
                                        </div>
                                    </div>
                                    
                                    <div class="metarule-card" data-metarule="inverse">
                                        <div class="metarule-header">
                                            <span class="metarule-name">Inverse</span>
                                            <span class="metarule-arity">Arity: 2</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(Y,X)</pre>
                                        <div class="metarule-description">
                                            <p>Argument swap</p>
                                            <p class="example">Example: <code>child(X,Y) ‚Üê parent(Y,X)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop">Non-recursive</span>
                                            <span class="prop">Symmetric relations</span>
                                        </div>
                                    </div>
                                    
                                    <div class="metarule-card" data-metarule="precon">
                                        <div class="metarule-header">
                                            <span class="metarule-name">Precon</span>
                                            <span class="metarule-arity">Arity: 2+1</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(X), R(X,Y)</pre>
                                        <div class="metarule-description">
                                            <p>Precondition pattern</p>
                                            <p class="example">Example: <code>can_vote(X,Y) ‚Üê adult(X), citizen(X,Y)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop">Non-recursive</span>
                                            <span class="prop">Guard condition</span>
                                        </div>
                                    </div>
                                    
                                    <div class="metarule-card" data-metarule="postcon">
                                        <div class="metarule-header">
                                            <span class="metarule-name">Postcon</span>
                                            <span class="metarule-arity">Arity: 2+1</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(X,Y), R(Y)</pre>
                                        <div class="metarule-description">
                                            <p>Postcondition pattern</p>
                                            <p class="example">Example: <code>hire(X,Y) ‚Üê interview(X,Y), qualified(Y)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop">Non-recursive</span>
                                            <span class="prop">Filter output</span>
                                        </div>
                                    </div>
                                    
                                    <div class="metarule-card highlight" data-metarule="chain">
                                        <div class="metarule-header">
                                            <span class="metarule-name">Chain</span>
                                            <span class="metarule-arity">Arity: 2+2</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(X,Z), R(Z,Y)</pre>
                                        <div class="metarule-description">
                                            <p>Composition through intermediate</p>
                                            <p class="example">Example: <code>grandparent(X,Y) ‚Üê parent(X,Z), parent(Z,Y)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop important">Most common</span>
                                            <span class="prop">Introduces new variable Z</span>
                                        </div>
                                    </div>
                                    
                                    <div class="metarule-card" data-metarule="tailrec">
                                        <div class="metarule-header">
                                            <span class="metarule-name">TailRec</span>
                                            <span class="metarule-arity">Arity: 2</span>
                                        </div>
                                        <pre class="metarule-template">P(X,Y) ‚Üê Q(X,Z), P(Z,Y)</pre>
                                        <div class="metarule-description">
                                            <p>Tail recursion</p>
                                            <p class="example">Example: <code>ancestor(X,Y) ‚Üê parent(X,Z), ancestor(Z,Y)</code></p>
                                        </div>
                                        <div class="metarule-properties">
                                            <span class="prop recursive">Recursive</span>
                                            <span class="prop">Transitive closure</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metarule-expressiveness">
                                <h5>Expressiveness vs. Efficiency Trade-off</h5>
                                <div class="tradeoff-diagram">
                                    <div class="tradeoff-axis">
                                        <span class="axis-label left">Fewer Metarules</span>
                                        <div class="axis-bar">
                                            <div class="axis-marker" style="left: 20%;">H‚ÇÇ‚ÇÇ</div>
                                            <div class="axis-marker" style="left: 50%;">Metagol</div>
                                            <div class="axis-marker" style="left: 80%;">Unrestricted</div>
                                        </div>
                                        <span class="axis-label right">More Metarules</span>
                                    </div>
                                    <div class="tradeoff-metrics">
                                        <div class="metric-row">
                                            <span class="metric-name">Search Space:</span>
                                            <span class="metric-value small">Small</span>
                                            <span class="metric-arrow">‚Üí</span>
                                            <span class="metric-value large">Huge</span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">Expressiveness:</span>
                                            <span class="metric-value limited">Limited</span>
                                            <span class="metric-arrow">‚Üí</span>
                                            <span class="metric-value full">Full</span>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-name">Learning Time:</span>
                                            <span class="metric-value fast">Fast</span>
                                            <span class="metric-arrow">‚Üí</span>
                                            <span class="metric-value slow">Slow/Undecidable</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="theorem-box">
                                    <h6>Theorem (Cropper & Muggleton, 2016)</h6>
                                    <p>
                                        The set {Identity, Inverse, Precon, Postcon, Chain, TailRec} can express 
                                        any definite hypothesis with at most two body literals.
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Refinement Operators -->
                        <div class="refinement-section">
                            <h4>Refinement Operators</h4>
                            <p class="section-intro">
                                Refinement operators define how to traverse the hypothesis lattice by generating 
                                <strong>specializations</strong> (downward) or <strong>generalizations</strong> (upward).
                            </p>
                            
                            <div class="refinement-types">
                                <div class="refinement-card downward">
                                    <h5>Downward Refinement (œÅ‚Üì)</h5>
                                    <div class="definition-box">
                                        <p>œÅ‚Üì(C) = {C' | C ‚â§Œ∏ C' and C' is a <em>minimal specialization</em> of C}</p>
                                    </div>
                                    <div class="refinement-operations">
                                        <h6>Operations:</h6>
                                        <ol>
                                            <li><strong>Add literal:</strong> C' = C ‚à™ {L} for some literal L</li>
                                            <li><strong>Apply substitution:</strong> C' = CŒ∏ for some Œ∏ = {X/t}</li>
                                            <li><strong>Remove literal:</strong> C' = C \ {L} (for generalizations, reversed)</li>
                                        </ol>
                                    </div>
                                    <div class="refinement-example">
                                        <h6>Example:</h6>
                                        <div class="refinement-tree">
                                            <div class="ref-node parent">
                                                <code>gp(X,Y) ‚Üê parent(X,Z)</code>
                                            </div>
                                            <div class="ref-children">
                                                <div class="ref-arrow">‚Üì</div>
                                                <div class="ref-node child">
                                                    <code>gp(X,Y) ‚Üê parent(X,Z), parent(Z,Y)</code>
                                                    <span class="op-label">add literal</span>
                                                </div>
                                                <div class="ref-node child">
                                                    <code>gp(X,Y) ‚Üê parent(X,Z), male(Z)</code>
                                                    <span class="op-label">add literal</span>
                                                </div>
                                                <div class="ref-node child">
                                                    <code>gp(X,Y) ‚Üê parent(X,Y)</code>
                                                    <span class="op-label">Œ∏={Z/Y}</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="refinement-card upward">
                                    <h5>Upward Refinement (œÅ‚Üë)</h5>
                                    <div class="definition-box">
                                        <p>œÅ‚Üë(C) = {C' | C' ‚â§Œ∏ C and C is a <em>minimal specialization</em> of C'}</p>
                                    </div>
                                    <div class="refinement-properties">
                                        <p>Used in <strong>bottom-up</strong> learners like GOLEM that start from 
                                        specific examples and generalize.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="operator-properties">
                                <h5>Ideal Refinement Operator Properties</h5>
                                <div class="properties-grid">
                                    <div class="property-card">
                                        <h6>Locally Finite</h6>
                                        <p>|œÅ(C)| is finite for all C</p>
                                        <span class="status good">‚úì Required</span>
                                    </div>
                                    <div class="property-card">
                                        <h6>Complete</h6>
                                        <p>Any target reachable from ‚ä§ or ‚ä•</p>
                                        <span class="status good">‚úì Required</span>
                                    </div>
                                    <div class="property-card">
                                        <h6>Proper</h6>
                                        <p>C' ‚àà œÅ(C) ‚Üí C' ‚â† C</p>
                                        <span class="status good">‚úì Desired</span>
                                    </div>
                                    <div class="property-card">
                                        <h6>Non-redundant</h6>
                                        <p>Each hypothesis generated once</p>
                                        <span class="status bad">‚úó Hard to achieve</span>
                                    </div>
                                </div>
                                
                                <div class="impossibility-theorem">
                                    <h6>Impossibility Result (van der Laag & Nienhuys-Cheng, 1994)</h6>
                                    <p>
                                        There is no ideal refinement operator for Œ∏-subsumption that is 
                                        simultaneously <em>complete</em>, <em>locally finite</em>, and <em>non-redundant</em>.
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- Type Systems -->
                        <div class="types-section">
                            <h4>Type Systems for ILP</h4>
                            <div class="type-hierarchy-demo">
                                <h5>Type Hierarchy Example</h5>
                                <div class="type-tree">
                                    <div class="type-node root">entity</div>
                                    <div class="type-level">
                                        <div class="type-branch">
                                            <div class="type-node">person</div>
                                            <div class="type-children">
                                                <div class="type-node leaf">adult</div>
                                                <div class="type-node leaf">child</div>
                                            </div>
                                        </div>
                                        <div class="type-branch">
                                            <div class="type-node">location</div>
                                            <div class="type-children">
                                                <div class="type-node leaf">city</div>
                                                <div class="type-node leaf">country</div>
                                            </div>
                                        </div>
                                        <div class="type-branch">
                                            <div class="type-node">number</div>
                                            <div class="type-children">
                                                <div class="type-node leaf">integer</div>
                                                <div class="type-node leaf">real</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="typed-modes-example">
                                    <h6>Typed Mode Declarations</h6>
                                    <pre class="code-block">% Type definitions
type(person, [alice, bob, carol, dave]).
type(adult, [alice, bob]).
type(child, [carol, dave]).

% Typed modes
modeh(1, grandparent(+adult, -child)).
modeb(*, parent(+person, -person)).

% Type constraint: adult ‚äÜ person, child ‚äÜ person</pre>
                                    <p class="example-explanation">
                                        Types reduce the hypothesis space by restricting variable domains. 
                                        This prevents ill-typed hypotheses like <code>grandparent(city, number)</code>.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Complexity Theory -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>Complexity-Theoretic Analysis</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="complexity-analysis">
                        <div class="theorem-card">
                            <div class="theorem-header">
                                <span class="theorem-type">Theorem</span>
                                <span class="theorem-name">Sample Complexity of ILP</span>
                            </div>
                            <div class="theorem-body">
                                <p>Under appropriate language biases, ILP can achieve <strong>logarithmic sample complexity</strong> O(log|H|), where |H| is the hypothesis space size.</p>
                                <div class="proof-sketch">
                                    <strong>Proof Sketch:</strong> Each example eliminates a constant fraction of hypotheses. After m examples, remaining hypotheses ‚â§ |H| ¬∑ (1-Œµ)^m. Setting this ‚â§ Œ¥ and solving for m gives m = O(log(|H|/Œ¥)/Œµ).
                                </div>
                            </div>
                        </div>

                        <div class="complexity-table">
                            <h4>Key Complexity Results</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Problem</th>
                                        <th>Complexity</th>
                                        <th>Reference</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Learning k-term DNF</td>
                                        <td>NP-hard</td>
                                        <td>Pitt & Valiant, 1988</td>
                                    </tr>
                                    <tr>
                                        <td>Learning Horn clauses (membership queries)</td>
                                        <td>Polynomial</td>
                                        <td>Angluin et al., 1992</td>
                                    </tr>
                                    <tr>
                                        <td>ILP with recursion (general)</td>
                                        <td>Undecidable</td>
                                        <td>D≈æeroski et al., 1992</td>
                                    </tr>
                                    <tr>
                                        <td>Progol's inverse entailment</td>
                                        <td>Polynomial (bounded)</td>
                                        <td>Muggleton, 1995</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="pac-learning">
                            <h4>PAC Learning Framework for ILP</h4>
                            <div class="math-block">
                                <p>A hypothesis class H is <strong>PAC learnable</strong> if there exists an algorithm A such that:</p>
                                <div class="formula">
                                    ‚àÄŒµ,Œ¥ > 0, ‚àÄD, ‚àÄc ‚àà H: P[error(h) ‚â§ Œµ] ‚â• 1-Œ¥
                                </div>
                                <p>where h = A(sample of size m = poly(1/Œµ, 1/Œ¥, size(c)))</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: Stories - Real-World ILP in Action -->
        <section id="stories" class="section">
            <div class="section-header">
                <span class="section-number">02</span>
                <h2 class="section-title">Stories from the Frontier</h2>
                <p class="section-desc">How ILP breakthroughs solve real problems‚Äîfrom puzzles to enterprise systems</p>
            </div>

            <!-- Story 1: The Eight-Puzzle Breakthrough -->
            <div class="content-block story-block" data-level="2">
                <div class="block-header">
                    <h3>üìñ Story 1: The Eight-Puzzle Breakthrough</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="story-narrative">
                        <div class="story-opening">
                            <p class="story-hook">
                                <em>It was supposed to be a simple benchmark. Instead, it exposed a fundamental flaw in how 
                                ILP systems search for rules‚Äîand led to a breakthrough that slashed learning time by 99%.</em>
                            </p>
                        </div>

                        <div class="story-body">
                            <div class="story-section">
                                <h4>The Problem</h4>
                                <p>
                                    The <strong>Eight-Puzzle</strong> is a classic AI benchmark: a 3√ó3 grid with 8 numbered tiles 
                                    and one empty space. The goal is to slide tiles to reach a target configuration. Researchers 
                                    at Oxford were testing POPPER‚Äîtheir state-of-the-art ILP system‚Äîon learning the game's 
                                    transition rules.
                                </p>
                                <div class="puzzle-visualization">
                                    <div class="puzzle-grid">
                                        <div class="tile">1</div><div class="tile">2</div><div class="tile">3</div>
                                        <div class="tile">4</div><div class="tile empty"></div><div class="tile">5</div>
                                        <div class="tile">6</div><div class="tile">7</div><div class="tile">8</div>
                                    </div>
                                    <span class="puzzle-arrow">‚Üí</span>
                                    <div class="puzzle-grid">
                                        <div class="tile">1</div><div class="tile">2</div><div class="tile">3</div>
                                        <div class="tile">4</div><div class="tile">5</div><div class="tile empty"></div>
                                        <div class="tile">6</div><div class="tile">7</div><div class="tile">8</div>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section crisis">
                                <h4>The Crisis</h4>
                                <p>
                                    After <strong>60 minutes</strong> of computation, POPPER hadn't found a solution. 
                                    The hypothesis space was vast, and the system was drowning in rules that could 
                                    <em>never</em> be correct‚Äîrules containing redundant predicates that would always 
                                    be implied by others.
                                </p>
                                <div class="crisis-box">
                                    <div class="crisis-stat">
                                        <span class="stat-value">60+ min</span>
                                        <span class="stat-label">Learning time (timeout)</span>
                                    </div>
                                    <div class="crisis-stat">
                                        <span class="stat-value">0%</span>
                                        <span class="stat-label">Problems solved</span>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section insight">
                                <h4>The Insight</h4>
                                <p>
                                    Andrew Cropper and David Cerna realized something profound: many rules were 
                                    <strong>"pointless"</strong>‚Äîthey contained literals that were either implied 
                                    by other literals (reducible) or couldn't distinguish positive from negative 
                                    examples (indiscriminate).
                                </p>
                                <div class="insight-example">
                                    <h5>Example of a Pointless Rule:</h5>
                                    <pre class="code-block">
move(State,NewState) ‚Üê 
    cell(State,Pos,empty),
    <span class="pointless">cell(State,Pos,Tile)</span>,  <!-- POINTLESS: empty ‚â† Tile always -->
    adjacent(Pos,NewPos)...</pre>
                                    <p class="explanation">
                                        The highlighted literal can never be true when the first literal is true‚Äî
                                        a position can't be both empty and contain a tile. POPPER was testing 
                                        millions of such impossible combinations.
                                    </p>
                                </div>
                            </div>

                            <div class="story-section solution">
                                <h4>The REDUCER Solution</h4>
                                <p>
                                    They developed <strong>REDUCER</strong>‚Äîan algorithm that detects pointless rules 
                                    <em>before</em> testing them. The key insight: if a literal is "captured" 
                                    (all its variables appear elsewhere), we can check if it's implied or useless.
                                </p>
                                <div class="solution-impact">
                                    <div class="before-after">
                                        <div class="before">
                                            <h5>Before REDUCER</h5>
                                            <span class="time">60+ minutes</span>
                                            <span class="result">‚ùå Timeout</span>
                                        </div>
                                        <div class="arrow">‚Üí</div>
                                        <div class="after">
                                            <h5>After REDUCER</h5>
                                            <span class="time">12 seconds</span>
                                            <span class="result">‚úÖ 100% accuracy</span>
                                        </div>
                                    </div>
                                    <div class="improvement-calc">
                                        <span class="improvement-value">99.7%</span>
                                        <span class="improvement-label">Time reduction</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="story-connection">
                            <h4>Connection to Core ILP Concepts</h4>
                            <div class="concept-connections">
                                <div class="connection-item">
                                    <span class="concept-tag">Hypothesis Space</span>
                                    <p>The Eight-Puzzle has a massive hypothesis space. REDUCER prunes entire subtrees of pointless rules.</p>
                                </div>
                                <div class="connection-item">
                                    <span class="concept-tag">Learning from Failures</span>
                                    <p>POPPER's constraint learning combines with REDUCER's pre-pruning for exponential speedup.</p>
                                </div>
                                <div class="connection-item">
                                    <span class="concept-tag">Background Knowledge</span>
                                    <p>REDUCER uses BK (e.g., "odd implies integer") to detect implied literals.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Story 2: The Lego Builder's Dilemma -->
            <div class="content-block story-block" data-level="3">
                <div class="block-header">
                    <h3>üìñ Story 2: The Lego Builder's Dilemma</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="story-narrative">
                        <div class="story-opening">
                            <p class="story-hook">
                                <em>A robot learns to build Lego structures‚Äîbut its learned "program" is a tangled mess 
                                of 500+ rules. Can we compress it without losing knowledge? This is the knowledge 
                                refactoring problem.</em>
                            </p>
                        </div>

                        <div class="story-body">
                            <div class="story-section">
                                <h4>The Scenario</h4>
                                <p>
                                    Imagine a robot learning to build Lego structures. After learning from many examples, 
                                    it has acquired hundreds of rules for different building patterns. But many rules 
                                    share common sub-patterns‚Äîrepeated code that could be factored out.
                                </p>
                                <div class="lego-example">
                                    <div class="lego-rules-before">
                                        <h5>Learned Rules (Redundant)</h5>
                                        <pre class="code-block">
build_tower(X) ‚Üê red(A), on(A,B), blue(B), on(B,X)
build_arch(X) ‚Üê red(A), on(A,B), blue(B), beside(B,C)
build_bridge(X) ‚Üê red(A), on(A,B), blue(B), span(B,X)</pre>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section">
                                <h4>The Challenge: Inventing New Concepts</h4>
                                <p>
                                    The pattern <code>red(A), on(A,B), blue(B)</code> appears in all three rules. 
                                    A human would naturally create a helper concept: "a red block on top of a blue block."
                                    But teaching machines to <em>invent</em> such concepts is NP-hard.
                                </p>
                                <div class="theorem-callout">
                                    <strong>MAXREFACTOR Theorem 1:</strong> The optimal knowledge refactoring problem 
                                    is NP-hard (via reduction from Maximum Independent Set).
                                </div>
                            </div>

                            <div class="story-section solution">
                                <h4>The MAXREFACTOR Innovation</h4>
                                <p>
                                    Liu et al. discovered that optimal refactoring can always use <strong>linear invented rules</strong>‚Äî
                                    rules where variables don't share between body literals. This reduces the encoding from 
                                    O(n¬∑2<sup>k</sup>) to O(n¬∑k), making the problem tractable.
                                </p>
                                <div class="refactoring-demo-story">
                                    <div class="refactored-rules">
                                        <h5>After MAXREFACTOR</h5>
                                        <pre class="code-block">
<span class="invented">red_on_blue(A,B) ‚Üê red(A), on(A,B), blue(B)</span>
build_tower(X) ‚Üê red_on_blue(A,B), on(B,X)
build_arch(X) ‚Üê red_on_blue(A,B), beside(B,C)
build_bridge(X) ‚Üê red_on_blue(A,B), span(B,X)</pre>
                                        <div class="compression-stats">
                                            <span>12 literals ‚Üí 10 literals</span>
                                            <span class="savings">17% compression</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section impact">
                                <h4>Real-World Impact</h4>
                                <div class="impact-grid">
                                    <div class="impact-card">
                                        <span class="impact-icon">ü§ñ</span>
                                        <h5>Robotics & Planning</h5>
                                        <p>Compressed programs transfer better to new tasks. A robot with compact knowledge generalizes to novel building challenges.</p>
                                    </div>
                                    <div class="impact-card">
                                        <span class="impact-icon">üß¨</span>
                                        <h5>Bioinformatics</h5>
                                        <p>Gene regulatory networks contain recurring motifs. Refactoring reveals these patterns automatically.</p>
                                    </div>
                                    <div class="impact-card">
                                        <span class="impact-icon">üìä</span>
                                        <h5>Business Rules</h5>
                                        <p>Enterprise rule engines accumulate redundancy. MAXREFACTOR can compress thousands of rules.</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="story-connection">
                            <h4>Connection to Core ILP Concepts</h4>
                            <div class="concept-connections">
                                <div class="connection-item">
                                    <span class="concept-tag">Predicate Invention</span>
                                    <p>MAXREFACTOR automatically invents helper predicates‚Äîa key ILP capability.</p>
                                </div>
                                <div class="connection-item">
                                    <span class="concept-tag">Constraint Optimization</span>
                                    <p>The problem is encoded as a COP and solved with standard solvers.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Story 3: The Teaching Paradox -->
            <div class="content-block story-block" data-level="2">
                <div class="block-header">
                    <h3>üìñ Story 3: The Teaching Paradox</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="story-narrative">
                        <div class="story-opening">
                            <p class="story-hook">
                                <em>39 volunteers tried to teach machines to code. The result? Random examples 
                                outperformed human-selected ones. This surprising finding challenges assumptions 
                                underlying program synthesis.</em>
                            </p>
                        </div>

                        <div class="story-body">
                            <div class="story-section">
                                <h4>The Experiment</h4>
                                <p>
                                    Researchers recruited 14 non-computer-scientists (NCS) and 25 computer science 
                                    students (CS) to teach six list-processing concepts to five different program 
                                    synthesis systems, including POPPER and an LLM (DeepSeek-Coder).
                                </p>
                                <div class="experiment-setup">
                                    <div class="participant-groups">
                                        <div class="group ncs">
                                            <span class="group-icon">üë§</span>
                                            <span class="group-name">Non-CS (14)</span>
                                        </div>
                                        <div class="group cs">
                                            <span class="group-icon">üíª</span>
                                            <span class="group-name">CS Students (25)</span>
                                        </div>
                                        <div class="group expert">
                                            <span class="group-icon">üéì</span>
                                            <span class="group-name">Expert (1)</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section crisis">
                                <h4>The Shocking Results</h4>
                                <div class="result-comparison">
                                    <div class="result-bar-chart">
                                        <div class="result-row">
                                            <span class="result-label">Expert</span>
                                            <div class="result-bar expert" style="width: 100%;">100%</div>
                                        </div>
                                        <div class="result-row">
                                            <span class="result-label">Random</span>
                                            <div class="result-bar random" style="width: 85%;">85%</div>
                                        </div>
                                        <div class="result-row">
                                            <span class="result-label">NCS</span>
                                            <div class="result-bar ncs" style="width: 76%;">76%</div>
                                        </div>
                                        <div class="result-row">
                                            <span class="result-label">CS</span>
                                            <div class="result-bar cs" style="width: 73%;">73%</div>
                                        </div>
                                    </div>
                                    <div class="shocking-finding">
                                        <span class="finding-icon">‚ö†Ô∏è</span>
                                        <p><strong>Random examples beat humans by 9-12 percentage points</strong></p>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section insight">
                                <h4>Why Humans Fail at Teaching Machines</h4>
                                <div class="failure-reasons-grid">
                                    <div class="reason-card">
                                        <h5>1. Too Simple</h5>
                                        <p>Humans give short lists (avg 4-5 elements). This allows ambiguous interpretations.</p>
                                        <div class="example-mini">
                                            <span class="bad">[1,2,3] ‚Üí 3</span>
                                            <span class="interpretation">Is it "last element" or "length"?</span>
                                        </div>
                                    </div>
                                    <div class="reason-card">
                                        <h5>2. Low Diversity</h5>
                                        <p>Element values cluster near small numbers, creating coincidental patterns.</p>
                                        <div class="example-mini">
                                            <span class="bad">[1,2,3,4,5]</span>
                                            <span class="interpretation">System learns "first < 2" instead of "sorted"</span>
                                        </div>
                                    </div>
                                    <div class="reason-card">
                                        <h5>3. Quantity ‚â† Quality</h5>
                                        <p>Non-experts gave MORE examples (6-7) than the expert (2-4), but worse results.</p>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section expert">
                                <h4>What the Expert Did Differently</h4>
                                <div class="expert-strategy">
                                    <div class="expert-example">
                                        <h5>Teaching "sorted"</h5>
                                        <div class="examples-list">
                                            <div class="example good">
                                                <code>[1,2,4,9,13,26,39,42] ‚Üí true</code>
                                                <span class="strategy">Long, varied values</span>
                                            </div>
                                            <div class="example good">
                                                <code>[1,2,4,9,<strong>26,25</strong>,39,42] ‚Üí false</code>
                                                <span class="strategy">Near-miss negative (one swap)</span>
                                            </div>
                                            <div class="example good">
                                                <code>[] ‚Üí true</code>
                                                <span class="strategy">Edge case</span>
                                            </div>
                                        </div>
                                        <p class="expert-insight">
                                            <strong>Key insight:</strong> The expert understood how ILP systems 
                                            search for rules and provided examples that disambiguate efficiently.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="story-connection">
                            <h4>Connection to Core ILP Concepts</h4>
                            <div class="concept-connections">
                                <div class="connection-item">
                                    <span class="concept-tag">Positive & Negative Examples</span>
                                    <p>The study shows that example QUALITY matters more than quantity. Near-miss negatives are crucial.</p>
                                </div>
                                <div class="connection-item">
                                    <span class="concept-tag">Active Learning</span>
                                    <p>This motivates systems that GUIDE users toward better examples.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Story 4: The Variable Explosion -->
            <div class="content-block story-block" data-level="4">
                <div class="block-header">
                    <h3>üìñ Story 4: The Variable Explosion</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="story-narrative">
                        <div class="story-opening">
                            <p class="story-hook">
                                <em>With just 9 variables, the solver explored identical hypotheses millions of times‚Äî
                                differing only in how variables were named. The solution required proving a problem 
                                was Graph Isomorphism hard, then finding a clever workaround.</em>
                            </p>
                        </div>

                        <div class="story-body">
                            <div class="story-section">
                                <h4>The Symmetry Problem</h4>
                                <p>
                                    When learning rules with multiple variables, ILP systems must consider all 
                                    possible variable assignments. But many assignments are <em>logically equivalent</em>‚Äî
                                    they differ only in which variable is called X vs Y.
                                </p>
                                <div class="symmetry-visualization">
                                    <div class="equivalent-rules">
                                        <pre class="code-block">
<span class="rule1">gp(A) ‚Üê parent(A,<strong>B</strong>), parent(<strong>B</strong>,<strong>C</strong>), tall(<strong>C</strong>)</span>
<span class="rule2">gp(A) ‚Üê parent(A,<strong>C</strong>), parent(<strong>C</strong>,<strong>B</strong>), tall(<strong>B</strong>)</span></pre>
                                        <p class="equivalence-note">
                                            These rules are <strong>identical</strong>‚Äîjust rename B‚ÜîC. 
                                            But the solver tests both!
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section crisis">
                                <h4>Exponential Explosion</h4>
                                <p>
                                    The number of equivalent rules grows factorially with variables:
                                </p>
                                <div class="explosion-table">
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Variables</th>
                                                <th>Permutations</th>
                                                <th>Solving Time</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr><td>5</td><td>120</td><td>0.1 sec</td></tr>
                                            <tr><td>7</td><td>5,040</td><td>12 sec</td></tr>
                                            <tr><td>8</td><td>40,320</td><td>6 min</td></tr>
                                            <tr class="crisis-row"><td>9</td><td>362,880</td><td>&gt;60 min ‚ùå</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            <div class="story-section insight">
                                <h4>The GI-Hardness Discovery</h4>
                                <p>
                                    Cropper, Cerna, and J√§rvisalo proved that detecting whether two rules are 
                                    equivalent (body-variants) is <strong>GI-hard</strong>‚Äîas hard as Graph Isomorphism.
                                </p>
                                <div class="theorem-box-story">
                                    <strong>Proposition 1:</strong> The body-variant problem is GI-hard.
                                    <p class="proof-intuition">
                                        <em>Intuition:</em> Encode a graph G=(V,E) as a rule with |V| variables and 
                                        edge predicates. Graph isomorphism reduces to checking if two such rules 
                                        are body-variants.
                                    </p>
                                </div>
                                <p>
                                    This means we <em>cannot</em> efficiently detect all symmetries. 
                                    But we can break <em>most</em> of them.
                                </p>
                            </div>

                            <div class="story-section solution">
                                <h4>The Safe Variable Solution</h4>
                                <p>
                                    The key insight: enforce a <strong>canonical ordering</strong> on variables. 
                                    If a variable is "skipped" in a literal, it must be "witnessed" by a 
                                    lexicographically smaller literal.
                                </p>
                                <div class="safe-variable-demo">
                                    <div class="safe-rule">
                                        <h5>Safe Rule (Keep)</h5>
                                        <pre class="code-block">h(A,B) ‚Üê p(A,C), p(B,D), p(C,E)</pre>
                                        <p>D is skipped in p(C,E), but witnessed by p(B,D)</p>
                                    </div>
                                    <div class="unsafe-rule">
                                        <h5>Unsafe Rule (Prune)</h5>
                                        <pre class="code-block">h(A,B) ‚Üê p(A,C), p(B,E), p(C,D)</pre>
                                        <p>D is skipped in p(B,E), but NOT witnessed</p>
                                    </div>
                                </div>
                            </div>

                            <div class="story-section impact">
                                <h4>The Result</h4>
                                <div class="before-after-story">
                                    <div class="before">
                                        <h5>9 Variables Without Symmetry Breaking</h5>
                                        <span class="time">&gt;60 minutes</span>
                                    </div>
                                    <div class="after">
                                        <h5>9 Variables With Symmetry Breaking</h5>
                                        <span class="time">17 seconds</span>
                                    </div>
                                </div>
                                <div class="improvement-stat">
                                    <span class="big-number">99.5%</span>
                                    <span class="label">Solving time reduction</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Industrial Applications -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>üè≠ ILP in Industry: Google, Microsoft, and Oracle</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="industry-applications">
                        <p class="intro-text">
                            While ILP originated in academia, its techniques power production systems at the 
                            world's largest technology companies. Understanding these applications reveals 
                            why the research advances above matter.
                        </p>

                        <div class="company-grid">
                            <!-- Google DeepMind -->
                            <div class="company-card deepmind">
                                <div class="company-header">
                                    <span class="company-logo">üß†</span>
                                    <h4>Google DeepMind</h4>
                                </div>
                                <div class="company-content">
                                    <h5>AlphaCode & Program Synthesis</h5>
                                    <p>
                                        DeepMind's AlphaCode generates programs from natural language descriptions. 
                                        While primarily neural, it uses constraint-based filtering to eliminate 
                                        semantically invalid programs‚Äîdirectly related to ILP's hypothesis pruning.
                                    </p>
                                    <div class="application-detail">
                                        <strong>Connection to ILP:</strong>
                                        <ul>
                                            <li>Semantic constraints eliminate impossible programs (like REDUCER)</li>
                                            <li>Clustering removes equivalent solutions (like Symmetry Breaking)</li>
                                            <li>Chain-of-thought prompting parallels ILP's compositional rule learning</li>
                                        </ul>
                                    </div>
                                    <h5>AlphaFold's Constraint Reasoning</h5>
                                    <p>
                                        AlphaFold uses geometric constraints to predict protein structure. 
                                        These constraints encode domain knowledge‚Äîanalogous to ILP's background knowledge.
                                    </p>
                                </div>
                            </div>

                            <!-- Microsoft -->
                            <div class="company-card microsoft">
                                <div class="company-header">
                                    <span class="company-logo">üìä</span>
                                    <h4>Microsoft</h4>
                                </div>
                                <div class="company-content">
                                    <h5>PROSE SDK & FlashFill</h5>
                                    <p>
                                        Microsoft's PROSE (Program Synthesis using Examples) SDK powers features 
                                        like Excel's FlashFill, which learns string transformations from examples.
                                    </p>
                                    <div class="application-detail">
                                        <strong>Connection to ILP:</strong>
                                        <ul>
                                            <li>Version Space Algebra organizes hypothesis space hierarchically</li>
                                            <li>Ranking heuristics prefer simpler programs (Occam's razor)</li>
                                            <li>Witness functions prune impossible subprograms</li>
                                        </ul>
                                    </div>
                                    <div class="real-world-example">
                                        <h6>FlashFill Example:</h6>
                                        <div class="flashfill-demo">
                                            <div class="input-output">
                                                <span class="input">"John Smith"</span>
                                                <span class="arrow">‚Üí</span>
                                                <span class="output">"J. Smith"</span>
                                            </div>
                                            <div class="learned-program">
                                                <code>Concat(SubStr(0,1), ". ", GetLastName())</code>
                                            </div>
                                        </div>
                                    </div>
                                    <h5>GitHub Copilot</h5>
                                    <p>
                                        Copilot combines LLMs with program analysis. The "Human Teaching" study 
                                        findings apply directly: users often provide insufficient context for 
                                        accurate code generation.
                                    </p>
                                </div>
                            </div>

                            <!-- Oracle -->
                            <div class="company-card oracle">
                                <div class="company-header">
                                    <span class="company-logo">üóÑÔ∏è</span>
                                    <h4>Oracle</h4>
                                </div>
                                <div class="company-content">
                                    <h5>SQL Query Optimization</h5>
                                    <p>
                                        Oracle's query optimizer learns cardinality estimation models and 
                                        access path selection rules‚Äîa form of rule learning from execution traces.
                                    </p>
                                    <div class="application-detail">
                                        <strong>Connection to ILP:</strong>
                                        <ul>
                                            <li>Cardinality histograms ‚âà background knowledge about data distributions</li>
                                            <li>Query plan enumeration ‚âà hypothesis space search</li>
                                            <li>Cost-based pruning ‚âà learning from failures</li>
                                        </ul>
                                    </div>
                                    <h5>Autonomous Database</h5>
                                    <p>
                                        Oracle's Autonomous Database uses ML to learn indexing and 
                                        partitioning rules‚Äîautomatically discovering patterns like 
                                        "queries filtering on date should use date-partitioned tables."
                                    </p>
                                </div>
                            </div>
                        </div>

                        <div class="industry-synthesis">
                            <h4>Why These Advances Matter for Industry</h4>
                            <div class="synthesis-points">
                                <div class="synthesis-point">
                                    <span class="point-icon">‚ö°</span>
                                    <div class="point-content">
                                        <h5>REDUCER ‚Üí Faster Synthesis</h5>
                                        <p>Production systems need sub-second response. A 99% speedup makes 
                                        interactive program synthesis feasible.</p>
                                    </div>
                                </div>
                                <div class="synthesis-point">
                                    <span class="point-icon">üì¶</span>
                                    <div class="point-content">
                                        <h5>MAXREFACTOR ‚Üí Smaller Models</h5>
                                        <p>Compressed rule bases are easier to deploy, debug, and explain. 
                                        Enterprise rule engines can have thousands of redundant rules.</p>
                                    </div>
                                </div>
                                <div class="synthesis-point">
                                    <span class="point-icon">üë§</span>
                                    <div class="point-content">
                                        <h5>Human Teaching ‚Üí Better UX</h5>
                                        <p>If users can't provide good examples, systems must guide them. 
                                        This informs UI design for Copilot, FlashFill, and no-code tools.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PhD-Level Technical Deep Dive -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>üéì PhD-Level: The Mathematical Foundations</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="phd-foundations">
                        <p class="intro-text">
                            The stories above illustrate practical impact. Here we formalize the theoretical 
                            contributions that make these advances possible.
                        </p>

                        <div class="theorem-collection">
                            <!-- REDUCER Theorems -->
                            <div class="theorem-section-phd">
                                <h4>REDUCER: Formal Definitions & Theorems</h4>
                                
                                <div class="definition-box-phd">
                                    <h5>Definition 7 (r-Captured Literal)</h5>
                                    <p>
                                        A literal l is <em>r-captured</em> in rule r = (h ‚Üê b) if 
                                        vars(l) ‚äÜ vars(h) ‚à™ vars(b \ {l}).
                                    </p>
                                    <p class="intuition">
                                        <em>Intuition:</em> All variables in l appear elsewhere in the rule.
                                    </p>
                                </div>

                                <div class="definition-box-phd">
                                    <h5>Definition 8 (Reducible Rule)</h5>
                                    <p>
                                        Rule r = (h ‚Üê b) is <em>reducible</em> if ‚àÉl ‚àà b such that l is r-captured 
                                        and BK ‚à™ (b \ {l}) ‚ä® l.
                                    </p>
                                </div>

                                <div class="theorem-box-phd">
                                    <h5>Proposition 1 (Specialization Closure)</h5>
                                    <p>
                                        If r‚ÇÅ is reducible and r‚ÇÅ ‚äÜ r‚ÇÇ (r‚ÇÇ specializes r‚ÇÅ), then r‚ÇÇ is reducible.
                                    </p>
                                    <div class="proof-sketch-phd">
                                        <strong>Proof Sketch:</strong> 
                                        If l is implied by b‚ÇÅ \ {l}, then l is also implied by b‚ÇÇ ‚äá b‚ÇÅ, 
                                        since adding literals only strengthens the antecedent. By Lemma 1, 
                                        if l is captured in r‚ÇÅ, it remains captured in r‚ÇÇ.
                                    </div>
                                </div>

                                <div class="corollary-box-phd">
                                    <h5>Corollary 1 (Soundness)</h5>
                                    <p>
                                        A pointless hypothesis is never optimal.
                                    </p>
                                    <p class="implication-phd">
                                        <strong>Algorithmic Implication:</strong> We can prune the entire subtree 
                                        rooted at a pointless rule without losing optimal solutions.
                                    </p>
                                </div>
                            </div>

                            <!-- Symmetry Breaking Theorems -->
                            <div class="theorem-section-phd">
                                <h4>Symmetry Breaking: Formal Definitions & Theorems</h4>

                                <div class="definition-box-phd">
                                    <h5>Definition 1 (Body-Variant)</h5>
                                    <p>
                                        Rules r‚ÇÅ and r‚ÇÇ are <em>body-variants</em> if ‚àÉ substitution Œ∏ such that 
                                        r‚ÇÅ = r‚ÇÇŒ∏ and head(r‚ÇÅ) = head(r‚ÇÇ).
                                    </p>
                                </div>

                                <div class="theorem-box-phd">
                                    <h5>Proposition 1 (GI-Hardness)</h5>
                                    <p>
                                        The body-variant problem is GI-hard.
                                    </p>
                                    <div class="proof-sketch-phd">
                                        <strong>Proof:</strong> 
                                        Given graph G = (N, E) with n nodes, construct rule:
                                        <pre class="code-inline">r_G = h(X‚ÇÅ,...,X‚Çô) ‚Üê {edge(X·µ¢, X‚±º) : (i,j) ‚àà E}</pre>
                                        Two graphs G‚ÇÅ, G‚ÇÇ are isomorphic iff r_{G‚ÇÅ} and r_{G‚ÇÇ} are body-variants.
                                    </div>
                                </div>

                                <div class="definition-box-phd">
                                    <h5>Definition (Safe Variable)</h5>
                                    <p>
                                        Variable X is <em>safe</em> in rule r if for every literal l ‚àà body(r) 
                                        where X ‚àà skipped(l), there exists l' &lt;<sub>lex</sub> l with X ‚àà vars(l').
                                    </p>
                                </div>

                                <div class="theorem-box-phd">
                                    <h5>Proposition 2 (Soundness of Safe Variables)</h5>
                                    <p>
                                        For every rule r, there exists a body-variant r' where all variables are safe.
                                    </p>
                                    <div class="proof-sketch-phd">
                                        <strong>Proof Sketch:</strong> 
                                        Construct r' by iteratively renaming variables to their canonical form. 
                                        The first occurrence of each variable in lexicographic order becomes its 
                                        canonical name. This process always produces a safe variant.
                                    </div>
                                </div>
                            </div>

                            <!-- MAXREFACTOR Theorems -->
                            <div class="theorem-section-phd">
                                <h4>MAXREFACTOR: Formal Definitions & Theorems</h4>

                                <div class="definition-box-phd">
                                    <h5>Problem: Optimal Knowledge Refactoring (OKR)</h5>
                                    <p>
                                        <strong>Input:</strong> Logic program P<br>
                                        <strong>Output:</strong> Program P' such that P ‚â° P' and |P'| is minimal
                                    </p>
                                </div>

                                <div class="theorem-box-phd">
                                    <h5>Theorem 1 (NP-Hardness)</h5>
                                    <p>
                                        The OKR problem is NP-hard.
                                    </p>
                                    <div class="proof-sketch-phd">
                                        <strong>Proof:</strong> 
                                        Reduction from Maximum Independent Set in 3-regular Hamiltonian graphs. 
                                        For graph G = (V, E), construct program P_G where optimal refactoring 
                                        corresponds to maximum independent set. The reduction is polynomial.
                                    </div>
                                </div>

                                <div class="theorem-box-phd">
                                    <h5>Theorem 2 (Linear Sufficiency)</h5>
                                    <p>
                                        If the OKR problem has a solution using invented rules C ‚äÜ S, then it has 
                                        a solution using C' ‚äÜ S<sub>lin</sub> where S<sub>lin</sub> = {lin(s) | s ‚àà S}.
                                    </p>
                                    <p class="implication-phd">
                                        <strong>Algorithmic Implication:</strong> We only need to consider 
                                        linear invented rules, reducing the search space from O(n¬∑2^k) to O(n¬∑k).
                                    </p>
                                </div>
                            </div>
                        </div>

                        <div class="complexity-summary">
                            <h4>Complexity Landscape Summary</h4>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Problem</th>
                                        <th>Complexity</th>
                                        <th>Approach</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Optimal Knowledge Refactoring</td>
                                        <td class="np-hard">NP-hard</td>
                                        <td>COP encoding with linear rule restriction</td>
                                    </tr>
                                    <tr>
                                        <td>Body-Variant Detection</td>
                                        <td class="gi-hard">GI-hard</td>
                                        <td>Sound but incomplete safe variable pruning</td>
                                    </tr>
                                    <tr>
                                        <td>Pointless Rule Detection</td>
                                        <td class="poly">Polynomial</td>
                                        <td>BK queries + example coverage checks</td>
                                    </tr>
                                    <tr>
                                        <td>Standard ILP</td>
                                        <td class="undecidable">Undecidable*</td>
                                        <td>Restrict hypothesis space (mode bias)</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p class="table-note">
                                *In the general case with unrestricted first-order logic. 
                                Practical ILP systems use language bias to ensure decidability.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Solvers -->
        <section id="solvers" class="section">
            <div class="section-header">
                <span class="section-number">03</span>
                <h2 class="section-title">Automated Reasoning Solvers</h2>
                <p class="section-desc">The computational engines that power modern ILP systems</p>
            </div>

            <!-- SAT Solvers -->
            <div class="content-block" data-level="2">
                <div class="block-header">
                    <h3>SAT Solvers</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="solver-intro">
                        <div class="solver-icon sat-icon">SAT</div>
                        <div class="solver-description">
                            <h4>Boolean Satisfiability Problem</h4>
                            <p>Given a propositional formula in CNF, determine if there exists a satisfying assignment.</p>
                        </div>
                    </div>

                    <!-- Interactive SAT Demo -->
                    <div class="sat-playground" id="satPlayground">
                        <h4>Interactive SAT Solver</h4>
                        <div class="sat-interface">
                            <div class="clause-builder">
                                <h5>Build Your Formula</h5>
                                <div class="variables-palette">
                                    <span class="var-btn" data-var="A">A</span>
                                    <span class="var-btn" data-var="B">B</span>
                                    <span class="var-btn" data-var="C">C</span>
                                    <span class="var-btn neg" data-var="¬¨">¬¨</span>
                                    <span class="var-btn op" data-var="‚à®">‚à®</span>
                                    <span class="var-btn op" data-var="‚àß">‚àß</span>
                                </div>
                                <div class="clauses-list" id="clausesList">
                                    <div class="clause">(A ‚à® B)</div>
                                    <div class="clause">(¬¨A ‚à® C)</div>
                                    <div class="clause">(¬¨B ‚à® ¬¨C)</div>
                                </div>
                                <div class="clause-input">
                                    <input type="text" id="newClause" placeholder="e.g., (A ‚à® ¬¨B)">
                                    <button class="btn-small" onclick="addClause()">Add Clause</button>
                                </div>
                            </div>
                            <div class="sat-execution">
                                <button class="btn btn-primary" onclick="solveSAT()">Solve SAT</button>
                                <div class="sat-result" id="satResult">
                                    <div class="result-status">Click "Solve SAT" to find a solution</div>
                                </div>
                                <div class="sat-trace" id="satTrace">
                                    <!-- DPLL trace will appear here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- DPLL Algorithm Visualization -->
                    <div class="algorithm-viz" data-level="3">
                        <h4>DPLL Algorithm</h4>
                        <div class="dpll-visualization" id="dpllViz">
                            <div class="dpll-tree">
                                <canvas id="dpllCanvas" width="700" height="400"></canvas>
                            </div>
                            <div class="dpll-controls">
                                <button class="btn-small" onclick="dpllStep()">Step</button>
                                <button class="btn-small" onclick="dpllRun()">Run</button>
                                <button class="btn-small" onclick="dpllReset()">Reset</button>
                            </div>
                            <div class="dpll-explanation" id="dpllExplanation">
                                <p>The DPLL algorithm searches for a satisfying assignment using:</p>
                                <ul>
                                    <li><strong>Unit Propagation:</strong> If a clause has one literal, it must be true</li>
                                    <li><strong>Pure Literal Elimination:</strong> If a variable appears with only one polarity, assign it</li>
                                    <li><strong>Branching:</strong> Pick a variable and try both assignments</li>
                                    <li><strong>Backtracking:</strong> If conflict, undo and try alternative</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- CDCL Advanced -->
                    <div class="cdcl-section" data-level="4">
                        <h4>Conflict-Driven Clause Learning (CDCL)</h4>
                        <div class="cdcl-explanation">
                            <p>Modern SAT solvers extend DPLL with learned clauses from conflicts:</p>
                            <div class="cdcl-diagram">
                                <div class="cdcl-step">
                                    <span class="step-num">1</span>
                                    <span class="step-name">Decide</span>
                                    <span class="step-desc">Pick unassigned variable</span>
                                </div>
                                <div class="cdcl-arrow">‚Üí</div>
                                <div class="cdcl-step">
                                    <span class="step-num">2</span>
                                    <span class="step-name">Propagate</span>
                                    <span class="step-desc">Apply unit propagation</span>
                                </div>
                                <div class="cdcl-arrow">‚Üí</div>
                                <div class="cdcl-step conflict">
                                    <span class="step-num">3</span>
                                    <span class="step-name">Conflict?</span>
                                    <span class="step-desc">Check for contradiction</span>
                                </div>
                                <div class="cdcl-arrow">‚Üí</div>
                                <div class="cdcl-step">
                                    <span class="step-num">4</span>
                                    <span class="step-name">Analyze</span>
                                    <span class="step-desc">Learn conflict clause</span>
                                </div>
                                <div class="cdcl-arrow">‚Üí</div>
                                <div class="cdcl-step">
                                    <span class="step-num">5</span>
                                    <span class="step-name">Backjump</span>
                                    <span class="step-desc">Non-chronological backtrack</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ASP Solvers -->
            <div class="content-block" data-level="2">
                <div class="block-header">
                    <h3>Answer Set Programming (ASP)</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="solver-intro">
                        <div class="solver-icon asp-icon">ASP</div>
                        <div class="solver-description">
                            <h4>Declarative Problem Solving</h4>
                            <p>Model problems as logic programs; solutions are stable models (answer sets).</p>
                        </div>
                    </div>

                    <!-- ASP Playground -->
                    <div class="asp-playground" id="aspPlayground">
                        <h4>ASP Editor</h4>
                        <div class="asp-interface">
                            <div class="asp-editor">
                                <div class="editor-header">
                                    <span>Program</span>
                                    <select id="aspExamples" onchange="loadASPExample()">
                                        <option value="coloring">Graph Coloring</option>
                                        <option value="nqueens">N-Queens</option>
                                        <option value="family">Family Relations</option>
                                        <option value="path">Path Finding</option>
                                    </select>
                                </div>
                                <textarea id="aspCode" rows="15">% Graph Coloring Problem
% Nodes
node(1). node(2). node(3). node(4).

% Edges  
edge(1,2). edge(2,3). edge(3,4). edge(4,1). edge(1,3).

% Colors
color(red). color(green). color(blue).

% Each node has exactly one color
1 { colored(N,C) : color(C) } 1 :- node(N).

% Adjacent nodes have different colors
:- edge(X,Y), colored(X,C), colored(Y,C).

#show colored/2.</textarea>
                            </div>
                            <div class="asp-output">
                                <div class="output-header">
                                    <span>Answer Sets</span>
                                    <button class="btn btn-primary" onclick="runASP()">Solve</button>
                                </div>
                                <div class="asp-results" id="aspResults">
                                    <div class="result-placeholder">Click "Solve" to compute answer sets</div>
                                </div>
                                <div class="asp-visualization" id="aspViz">
                                    <!-- Graph visualization will appear here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Stable Model Semantics -->
                    <div class="stable-models" data-level="4">
                        <h4>Stable Model Semantics</h4>
                        <div class="semantics-explanation">
                            <div class="definition-box">
                                <h5>Definition: Stable Model</h5>
                                <p>A set S of ground atoms is a <em>stable model</em> of program P if S is the minimal model of the <em>reduct</em> P<sup>S</sup>.</p>
                            </div>
                            <div class="reduct-example">
                                <h5>Reduct Construction</h5>
                                <div class="code-comparison">
                                    <div class="code-before">
                                        <span class="label">Original Program P</span>
                                        <pre>a :- not b.
b :- not a.
c :- a.</pre>
                                    </div>
                                    <div class="code-after">
                                        <span class="label">Reduct P<sup>{a,c}</sup></span>
                                        <pre>a.
c :- a.</pre>
                                    </div>
                                </div>
                                <p>Stable models: {a, c} and {b}</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SMT Solvers -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>SMT Solvers</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="solver-intro">
                        <div class="solver-icon smt-icon">SMT</div>
                        <div class="solver-description">
                            <h4>Satisfiability Modulo Theories</h4>
                            <p>Extends SAT with first-order formulas over background theories like arithmetic, arrays, and bit-vectors.</p>
                        </div>
                    </div>

                    <div class="smt-theories">
                        <h4>Common Theories</h4>
                        <div class="theory-cards">
                            <div class="theory-card">
                                <h5>LIA - Linear Integer Arithmetic</h5>
                                <code>x + 2y ‚â§ 10 ‚àß x ‚â• 0 ‚àß y ‚â• 0</code>
                            </div>
                            <div class="theory-card">
                                <h5>LRA - Linear Real Arithmetic</h5>
                                <code>x/2 + y/3 = 1 ‚àß x ‚â• 0</code>
                            </div>
                            <div class="theory-card">
                                <h5>BV - Bit-Vectors</h5>
                                <code>x[7:0] & 0xFF = 0x42</code>
                            </div>
                            <div class="theory-card">
                                <h5>UF - Uninterpreted Functions</h5>
                                <code>f(x) = f(y) ‚Üí x = y</code>
                            </div>
                        </div>
                    </div>

                    <!-- SMT for ILP -->
                    <div class="smt-ilp" data-level="4">
                        <h4>SMT for Learning Numeric Rules</h4>
                        <div class="smt-example">
                            <p>Learn classification rules with arithmetic constraints:</p>
                            <div class="code-block">
                                <pre><code>% Learning: approve(X) if age(X) > ? ‚àß income(X) > ?

% Examples:
approve(alice). age(alice, 35). income(alice, 60000).
approve(bob). age(bob, 45). income(bob, 55000).
¬¨approve(charlie). age(charlie, 22). income(charlie, 30000).

% SMT finds thresholds:
approve(X) :- age(X, A), A > 30, income(X, I), I > 50000.</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- MaxSAT -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>MaxSAT Optimization</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="solver-intro">
                        <div class="solver-icon maxsat-icon">Max</div>
                        <div class="solver-description">
                            <h4>Maximum Satisfiability</h4>
                            <p>Find an assignment that satisfies all hard clauses and maximizes satisfied soft clauses.</p>
                        </div>
                    </div>

                    <!-- MaxSAT Demo -->
                    <div class="maxsat-demo" id="maxsatDemo">
                        <h4>MaxSAT for Noise-Tolerant Learning</h4>
                        <div class="maxsat-interface">
                            <div class="clauses-panel">
                                <div class="hard-clauses">
                                    <h5>Hard Clauses (Must satisfy)</h5>
                                    <div class="clause-list" id="hardClauses">
                                        <div class="clause hard">Hypothesis must be consistent</div>
                                        <div class="clause hard">Syntax constraints must hold</div>
                                    </div>
                                </div>
                                <div class="soft-clauses">
                                    <h5>Soft Clauses (Prefer to satisfy)</h5>
                                    <div class="clause-list" id="softClauses">
                                        <div class="clause soft" data-weight="1">Cover example e‚ÇÅ (w=1)</div>
                                        <div class="clause soft" data-weight="1">Cover example e‚ÇÇ (w=1)</div>
                                        <div class="clause soft" data-weight="1">Cover example e‚ÇÉ (w=1)</div>
                                        <div class="clause soft" data-weight="0.5">Prefer shorter rules (w=0.5)</div>
                                    </div>
                                </div>
                            </div>
                            <div class="maxsat-result">
                                <h5>Optimization Result</h5>
                                <div class="result-viz" id="maxsatResult">
                                    <div class="satisfied-count">
                                        <span class="count">3/4</span>
                                        <span class="label">Soft clauses satisfied</span>
                                    </div>
                                    <div class="optimal-assignment">
                                        <code>H = p(X) :- q(X), r(X)</code>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Solver Comparison -->
            <div class="content-block" data-level="2">
                <div class="block-header">
                    <h3>Solver Comparison & Selection</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="solver-comparison">
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Solver Type</th>
                                    <th>Input Language</th>
                                    <th>Strengths</th>
                                    <th>ILP Use Case</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="solver-badge sat">SAT</span></td>
                                    <td>Propositional CNF</td>
                                    <td>Speed, scalability</td>
                                    <td>Bounded hypothesis search</td>
                                </tr>
                                <tr>
                                    <td><span class="solver-badge asp">ASP</span></td>
                                    <td>Logic programs</td>
                                    <td>Expressiveness, enumeration</td>
                                    <td>ILASP, learning ASP rules</td>
                                </tr>
                                <tr>
                                    <td><span class="solver-badge smt">SMT</span></td>
                                    <td>First-order + theories</td>
                                    <td>Numeric constraints</td>
                                    <td>Learning with arithmetic</td>
                                </tr>
                                <tr>
                                    <td><span class="solver-badge maxsat">MaxSAT</span></td>
                                    <td>Weighted CNF</td>
                                    <td>Optimization, noise</td>
                                    <td>Noisy data, preferences</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: ILP Systems -->
        <section id="systems" class="section">
            <div class="section-header">
                <span class="section-number">04</span>
                <h2 class="section-title">ILP Systems & Algorithms</h2>
                <p class="section-desc">Historical and state-of-the-art systems for learning logic programs</p>
            </div>

            <!-- Timeline -->
            <div class="content-block" data-level="2">
                <div class="block-header">
                    <h3>Evolution of ILP Systems</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="timeline" id="ilpTimeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-item" data-year="1990">
                            <div class="timeline-marker"></div>
                            <div class="timeline-content">
                                <span class="timeline-year">1990</span>
                                <h4>FOIL</h4>
                                <p>First practical ILP system. Top-down, sequential covering with information gain.</p>
                                <span class="timeline-author">Quinlan</span>
                            </div>
                        </div>
                        <div class="timeline-item" data-year="1995">
                            <div class="timeline-marker"></div>
                            <div class="timeline-content">
                                <span class="timeline-year">1995</span>
                                <h4>Progol</h4>
                                <p>Inverse entailment. Mode declarations and bottom clause construction.</p>
                                <span class="timeline-author">Muggleton</span>
                            </div>
                        </div>
                        <div class="timeline-item" data-year="2014">
                            <div class="timeline-marker"></div>
                            <div class="timeline-content">
                                <span class="timeline-year">2014</span>
                                <h4>ILASP</h4>
                                <p>Learning Answer Set Programs using ASP solvers.</p>
                                <span class="timeline-author">Law, Russo, Broda</span>
                            </div>
                        </div>
                        <div class="timeline-item" data-year="2016">
                            <div class="timeline-marker"></div>
                            <div class="timeline-content">
                                <span class="timeline-year">2016</span>
                                <h4>Metagol</h4>
                                <p>Meta-interpretive learning. Predicate invention and recursion.</p>
                                <span class="timeline-author">Cropper & Muggleton</span>
                            </div>
                        </div>
                        <div class="timeline-item" data-year="2021">
                            <div class="timeline-marker"></div>
                            <div class="timeline-content">
                                <span class="timeline-year">2021</span>
                                <h4>Popper</h4>
                                <p>Learning from failures. Hypothesis constraints via ASP.</p>
                                <span class="timeline-author">Cropper & Morel</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Popper Deep Dive - Conceptual Explanation -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>Popper: Learning from Failures</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="popper-explanation">
                        <div class="key-insight">
                            <div class="insight-icon">üí°</div>
                            <div class="insight-text">
                                <strong>Key Insight:</strong> Instead of searching for correct hypotheses directly, 
                                learn constraints from failed hypotheses to prune the search space exponentially.
                                This is the foundation upon which REDUCER, Symmetry Breaking, and MAXREFACTOR build.
                            </div>
                        </div>

                        <!-- Link to Interactive Playground -->
                        <div class="try-interactive-box">
                            <span class="try-icon">üî¨</span>
                            <div class="try-content">
                                <strong>Try it yourself!</strong> 
                                Explore the interactive Popper simulator in the <a href="#playground" onclick="scrollToSection('playground')">Playground section</a> 
                                to see the hypothesis lattice, constraint learning, and pruning in action.
                            </div>
                        </div>

                        <!-- The Generate-Test-Constrain Loop -->
                        <div class="gtc-loop-section">
                            <h4>The Generate-Test-Constrain Loop</h4>
                            <div class="gtc-diagram">
                                <div class="gtc-step generate">
                                    <div class="step-number">1</div>
                                    <div class="step-content">
                                        <h5>Generate</h5>
                                        <p>ASP solver (Clingo) generates a hypothesis H consistent with all learned constraints</p>
                                    </div>
                                </div>
                                <div class="gtc-arrow">‚Üí</div>
                                <div class="gtc-step test">
                                    <div class="step-number">2</div>
                                    <div class="step-content">
                                        <h5>Test</h5>
                                        <p>Prolog tests if H covers all E‚Å∫ and no E‚Åª</p>
                                    </div>
                                </div>
                                <div class="gtc-arrow">‚Üí</div>
                                <div class="gtc-step constrain">
                                    <div class="step-number">3</div>
                                    <div class="step-content">
                                        <h5>Constrain</h5>
                                        <p>Analyze failure, learn constraints, prune search space</p>
                                    </div>
                                </div>
                                <div class="gtc-loop-back">‚Ü∫ Loop until solution or exhausted</div>
                            </div>
                        </div>

                        <!-- Constraint Types -->
                        <div class="constraint-types">
                            <h4>Constraint Types in Popper</h4>
                            <p class="constraint-intro">
                                When a hypothesis fails, Popper analyzes <em>why</em> it failed and learns constraints to avoid similar failures.
                                This is the key innovation that enables exponential pruning of the search space.
                            </p>
                            <div class="constraint-cards">
                                <div class="constraint-card generalization">
                                    <div class="card-header">
                                        <span class="card-icon">‚Üë</span>
                                        <h5>Generalization Constraint</h5>
                                    </div>
                                    <p>If H is <em>too specific</em> (doesn't cover some E‚Å∫), then all specializations of H are also too specific.</p>
                                    <div class="constraint-example">
                                        <div class="example-hyp">
                                            <span class="label">H:</span>
                                            <code>gp(X,Y) ‚Üê parent(X,Z), parent(Z,Y), male(Z)</code>
                                        </div>
                                        <div class="example-action">
                                            <span class="arrow">‚Üí</span>
                                            <span class="action-text">Prune all H' ‚äá H (adding more literals won't help)</span>
                                        </div>
                                    </div>
                                    <div class="research-link">
                                        <span class="link-icon">üìÑ</span>
                                        <span>Extended by <strong>REDUCER</strong>: Also prunes rules with implied literals</span>
                                    </div>
                                </div>
                                
                                <div class="constraint-card specialization">
                                    <div class="card-header">
                                        <span class="card-icon">‚Üì</span>
                                        <h5>Specialization Constraint</h5>
                                    </div>
                                    <p>If H is <em>too general</em> (covers some E‚Åª), then all generalizations of H are also too general.</p>
                                    <div class="constraint-example">
                                        <div class="example-hyp">
                                            <span class="label">H:</span>
                                            <code>gp(X,Y) ‚Üê parent(X,_)</code>
                                        </div>
                                        <div class="example-action">
                                            <span class="arrow">‚Üí</span>
                                            <span class="action-text">Prune all H' ‚äÜ H (removing literals won't help)</span>
                                        </div>
                                    </div>
                                    <div class="research-link">
                                        <span class="link-icon">üìÑ</span>
                                        <span>Extended by <strong>Symmetry Breaking</strong>: Also prunes body-variants</span>
                                    </div>
                                </div>
                                
                                <div class="constraint-card elimination">
                                    <div class="card-header">
                                        <span class="card-icon">‚úï</span>
                                        <h5>Elimination Constraint</h5>
                                    </div>
                                    <p>If H is <em>redundant</em> or logically equivalent to a tested hypothesis, eliminate it.</p>
                                    <div class="constraint-example">
                                        <div class="example-hyp">
                                            <span class="label">H:</span>
                                            <code>gp(X,Y) ‚Üê parent(X,Z), parent(Z,Y), parent(Z,Y)</code>
                                        </div>
                                        <div class="example-action">
                                            <span class="arrow">‚Üí</span>
                                            <span class="action-text">Eliminate H (duplicate literal)</span>
                                        </div>
                                    </div>
                                    <div class="research-link">
                                        <span class="link-icon">üìÑ</span>
                                        <span>Extended by <strong>MAXREFACTOR</strong>: Compresses learned programs</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- How Research Papers Extend Popper -->
                        <div class="popper-extensions">
                            <h4>How Recent Research Extends Popper</h4>
                            <div class="extension-flow">
                                <div class="flow-node popper-core">
                                    <div class="node-title">POPPER Core</div>
                                    <div class="node-desc">Generate-Test-Constrain Loop</div>
                                </div>
                                <div class="flow-arrows">
                                    <div class="arrow-branch top"></div>
                                    <div class="arrow-branch mid"></div>
                                    <div class="arrow-branch bot"></div>
                                </div>
                                <div class="flow-extensions">
                                    <div class="extension-node reducer">
                                        <div class="ext-name">REDUCER</div>
                                        <div class="ext-action">Pre-prune pointless rules</div>
                                        <div class="ext-result">99% time reduction</div>
                                    </div>
                                    <div class="extension-node symmetry">
                                        <div class="ext-name">Symmetry Breaking</div>
                                        <div class="ext-action">Eliminate body-variants</div>
                                        <div class="ext-result">99.5% solving reduction</div>
                                    </div>
                                    <div class="extension-node refactor">
                                        <div class="ext-name">MAXREFACTOR</div>
                                        <div class="ext-action">Post-compress programs</div>
                                        <div class="ext-result">60% better compression</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Pseudocode -->
                        <div class="algorithm-pseudocode" data-level="4">
                            <h4>Popper Algorithm (Cropper & Morel 2021)</h4>
                            <div class="code-block">
                                <pre><code class="python"><span class="keyword">def</span> <span class="function">popper</span>(B, E_pos, E_neg):
    <span class="comment"># Initialize constraint set</span>
    constraints = <span class="builtin">set</span>()
    
    <span class="keyword">while</span> <span class="const">True</span>:
        <span class="comment"># ASP solver generates hypothesis consistent with constraints</span>
        H = <span class="function">generate</span>(constraints)  <span class="comment"># Uses Clingo</span>
        
        <span class="keyword">if</span> H <span class="keyword">is</span> <span class="const">None</span>:
            <span class="keyword">return</span> <span class="const">None</span>  <span class="comment"># No solution exists in hypothesis space</span>
        
        <span class="comment"># Test hypothesis against examples</span>
        pos_covered = <span class="function">covers</span>(B, H, E_pos)
        neg_covered = <span class="function">covers</span>(B, H, E_neg)
        
        <span class="keyword">if</span> pos_covered == <span class="builtin">len</span>(E_pos) <span class="keyword">and</span> neg_covered == <span class="number">0</span>:
            <span class="keyword">return</span> H  <span class="comment"># ‚úì Found solution!</span>
        
        <span class="comment"># Analyze failure and learn constraints</span>
        <span class="keyword">if</span> pos_covered < <span class="builtin">len</span>(E_pos):
            <span class="comment"># H is too specific ‚Üí add generalization constraint</span>
            constraints.<span class="function">add</span>(<span class="function">gen_constraint</span>(H))
            <span class="comment"># Prunes all specializations of H</span>
        
        <span class="keyword">if</span> neg_covered > <span class="number">0</span>:
            <span class="comment"># H is too general ‚Üí add specialization constraint</span>
            constraints.<span class="function">add</span>(<span class="function">spec_constraint</span>(H))
            <span class="comment"># Prunes all generalizations of H</span>
        
        <span class="comment"># Always eliminate the tested hypothesis</span>
        constraints.<span class="function">add</span>(<span class="function">elim_constraint</span>(H))</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Metagol -->
            <div class="content-block" data-level="4">
                <div class="block-header">
                    <h3>Meta-Interpretive Learning (Metagol)</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="metagol-section">
                        <div class="metarules-explanation">
                            <h4>Metarules: Higher-Order Templates</h4>
                            <p>Metarules define the structure of learnable hypotheses:</p>
                            <div class="metarules-grid">
                                <div class="metarule-card">
                                    <div class="metarule-name">Identity</div>
                                    <code>P(X,Y) :- Q(X,Y)</code>
                                </div>
                                <div class="metarule-card">
                                    <div class="metarule-name">Inverse</div>
                                    <code>P(X,Y) :- Q(Y,X)</code>
                                </div>
                                <div class="metarule-card">
                                    <div class="metarule-name">Chain</div>
                                    <code>P(X,Y) :- Q(X,Z), R(Z,Y)</code>
                                </div>
                                <div class="metarule-card">
                                    <div class="metarule-name">Precon</div>
                                    <code>P(X,Y) :- Q(X), R(X,Y)</code>
                                </div>
                                <div class="metarule-card">
                                    <div class="metarule-name">Postcon</div>
                                    <code>P(X,Y) :- Q(X,Y), R(Y)</code>
                                </div>
                                <div class="metarule-card">
                                    <div class="metarule-name">Tail Recursion</div>
                                    <code>P(X,Y) :- Q(X,Z), P(Z,Y)</code>
                                </div>
                            </div>
                        </div>

                        <div class="predicate-invention">
                            <h4>Predicate Invention</h4>
                            <p>Metagol can invent new predicates not in the vocabulary:</p>
                            <div class="invention-example">
                                <div class="before">
                                    <span class="label">Given</span>
                                    <pre>% Examples of grandparent
grandparent(ann, carol).
grandparent(bob, david).</pre>
                                </div>
                                <div class="after">
                                    <span class="label">Learned (with invented predicate)</span>
                                    <pre>grandparent(X,Z) :- inv1(X,Y), inv1(Y,Z).
inv1(X,Y) :- parent(X,Y).  % Invented!</pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ILASP -->
            <div class="content-block" data-level="4">
                <div class="block-header">
                    <h3>ILASP: Learning Answer Set Programs</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="ilasp-section">
                        <div class="ilasp-features">
                            <h4>Key Capabilities</h4>
                            <div class="feature-list">
                                <div class="feature">
                                    <span class="feature-icon">üîÑ</span>
                                    <div class="feature-content">
                                        <strong>Non-Monotonic Reasoning</strong>
                                        <p>Learn default rules and exceptions</p>
                                    </div>
                                </div>
                                <div class="feature">
                                    <span class="feature-icon">üìä</span>
                                    <div class="feature-content">
                                        <strong>Noise Handling</strong>
                                        <p>Brave/cautious semantics for uncertain data</p>
                                    </div>
                                </div>
                                <div class="feature">
                                    <span class="feature-icon">‚öñÔ∏è</span>
                                    <div class="feature-content">
                                        <strong>Preference Learning</strong>
                                        <p>Learn weak constraints and optimization criteria</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="ilasp-example">
                            <h4>Learning Task Example</h4>
                            <div class="code-block">
                                <pre><code>% Mode declarations
#modeh(flies(var(bird))).
#modeb(bird(var(bird))).
#modeb(penguin(var(bird))).
#modeb(not abnormal(var(bird))).

% Background knowledge
bird(tweety). bird(polly). penguin(tweety).

% Positive examples (contexts where flies should hold)
#pos({flies(polly)}, {}, {bird(polly)}).

% Negative examples  
#neg({flies(tweety)}, {}, {bird(tweety), penguin(tweety)}).

% ILASP learns:
% flies(X) :- bird(X), not abnormal(X).
% abnormal(X) :- penguin(X).</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Playground -->
        <section id="playground" class="section">
            <div class="section-header">
                <span class="section-number">05</span>
                <h2 class="section-title">Interactive Playground</h2>
                <p class="section-desc">Hands-on experimentation with ILP concepts</p>
            </div>

            <!-- Family Relations Playground -->
            <div class="content-block playground-block" data-level="1">
                <div class="block-header">
                    <h3>üè† Family Relations Learning</h3>
                    <span class="complexity-badge beginner">Beginner</span>
                </div>
                <div class="block-content">
                    <div class="family-playground" id="familyPlayground">
                        <div class="playground-layout">
                            <div class="family-tree-builder">
                                <h4>Build Your Family Tree</h4>
                                <div class="tree-canvas-container">
                                    <canvas id="familyCanvas" width="400" height="350"></canvas>
                                </div>
                                <div class="tree-controls">
                                    <input type="text" id="personName" placeholder="Name">
                                    <button class="btn-small" onclick="addPerson()">Add Person</button>
                                    <div class="relation-builder">
                                        <select id="person1"></select>
                                        <span>is parent of</span>
                                        <select id="person2"></select>
                                        <button class="btn-small" onclick="addRelation()">Add</button>
                                    </div>
                                </div>
                            </div>
                            <div class="learning-panel">
                                <h4>Define Learning Task</h4>
                                <div class="target-predicate">
                                    <label>Target Predicate:</label>
                                    <select id="targetPredicate" onchange="updateLearningTask()">
                                        <option value="grandparent">grandparent(X, Y)</option>
                                        <option value="sibling">sibling(X, Y)</option>
                                        <option value="uncle">uncle(X, Y)</option>
                                        <option value="ancestor">ancestor(X, Y)</option>
                                    </select>
                                </div>
                                <div class="examples-builder">
                                    <div class="positive-examples">
                                        <h5>Positive Examples</h5>
                                        <div id="familyPosExamples" class="example-list"></div>
                                        <div class="add-example">
                                            <select id="posEx1"></select>
                                            <select id="posEx2"></select>
                                            <button class="btn-small" onclick="addFamilyPosExample()">+</button>
                                        </div>
                                    </div>
                                    <div class="negative-examples">
                                        <h5>Negative Examples</h5>
                                        <div id="familyNegExamples" class="example-list"></div>
                                        <div class="add-example">
                                            <select id="negEx1"></select>
                                            <select id="negEx2"></select>
                                            <button class="btn-small" onclick="addFamilyNegExample()">-</button>
                                        </div>
                                    </div>
                                </div>
                                <button class="btn btn-primary" onclick="learnFamilyRule()">Learn Rule!</button>
                                <div class="learned-result" id="familyLearnedRule">
                                    <div class="result-placeholder">Define examples and click "Learn Rule!"</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pattern Learning Playground -->
            <div class="content-block playground-block" data-level="2">
                <div class="block-header">
                    <h3>üî¢ Pattern Learning</h3>
                    <span class="complexity-badge intermediate">Intermediate</span>
                </div>
                <div class="block-content">
                    <div class="pattern-playground" id="patternPlayground">
                        <div class="pattern-interface">
                            <div class="sequence-input">
                                <h4>Input Sequence</h4>
                                <div class="sequence-display" id="sequenceDisplay">
                                    <span class="seq-item positive">2</span>
                                    <span class="seq-item positive">4</span>
                                    <span class="seq-item positive">6</span>
                                    <span class="seq-item negative">7</span>
                                    <span class="seq-item positive">8</span>
                                    <span class="seq-item negative">9</span>
                                </div>
                                <div class="sequence-controls">
                                    <input type="number" id="newNumber" placeholder="Number">
                                    <button class="btn-small positive" onclick="addSequenceItem(true)">+ Positive</button>
                                    <button class="btn-small negative" onclick="addSequenceItem(false)">+ Negative</button>
                                    <button class="btn-small" onclick="clearSequence()">Clear</button>
                                </div>
                            </div>
                            <div class="pattern-predicates">
                                <h4>Available Predicates</h4>
                                <div class="predicate-toggles">
                                    <label><input type="checkbox" checked value="even"> even(X)</label>
                                    <label><input type="checkbox" checked value="odd"> odd(X)</label>
                                    <label><input type="checkbox" checked value="prime"> prime(X)</label>
                                    <label><input type="checkbox" value="square"> square(X)</label>
                                    <label><input type="checkbox" value="divisible3"> divisible_by_3(X)</label>
                                    <label><input type="checkbox" value="greater10"> greater_than_10(X)</label>
                                </div>
                            </div>
                            <button class="btn btn-primary" onclick="learnPattern()">Induce Rule</button>
                            <div class="pattern-result" id="patternResult">
                                <div class="result-placeholder">Add examples and click "Induce Rule"</div>
                            </div>
                            <div class="pattern-test">
                                <h4>Test Your Rule</h4>
                                <input type="number" id="testNumber" placeholder="Enter a number">
                                <button class="btn-small" onclick="testPattern()">Test</button>
                                <span id="testResult"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- List Manipulation Playground -->
            <div class="content-block playground-block" data-level="3">
                <div class="block-header">
                    <h3>üìù List Manipulation Learning</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="list-playground" id="listPlayground">
                        <div class="list-interface">
                            <div class="list-examples">
                                <h4>Input/Output Examples</h4>
                                <div class="io-examples" id="ioExamples">
                                    <div class="io-pair">
                                        <span class="input">[1, 2, 3]</span>
                                        <span class="arrow">‚Üí</span>
                                        <span class="output">[3, 2, 1]</span>
                                    </div>
                                    <div class="io-pair">
                                        <span class="input">[a, b]</span>
                                        <span class="arrow">‚Üí</span>
                                        <span class="output">[b, a]</span>
                                    </div>
                                </div>
                                <div class="io-input">
                                    <input type="text" id="listInput" placeholder="Input: [1,2,3]">
                                    <input type="text" id="listOutput" placeholder="Output: [3,2,1]">
                                    <button class="btn-small" onclick="addIOExample()">Add</button>
                                </div>
                            </div>
                            <div class="list-primitives">
                                <h4>Available Primitives</h4>
                                <div class="primitive-list">
                                    <code>head(L, H)</code> - First element
                                    <code>tail(L, T)</code> - Rest of list
                                    <code>cons(H, T, L)</code> - Construct list
                                    <code>append(A, B, C)</code> - Concatenate
                                    <code>empty(L)</code> - Empty list check
                                </div>
                            </div>
                            <div class="metarule-selection">
                                <h4>Select Metarules</h4>
                                <div class="metarule-toggles">
                                    <label><input type="checkbox" checked value="base"> Base case</label>
                                    <label><input type="checkbox" checked value="chain"> Chain</label>
                                    <label><input type="checkbox" checked value="tailrec"> Tail recursion</label>
                                </div>
                            </div>
                            <button class="btn btn-primary" onclick="learnListProgram()">Synthesize Program</button>
                            <div class="list-result" id="listResult">
                                <div class="result-placeholder">Add I/O examples and synthesize</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Popper Simulator with Graph Visualization -->
            <div class="content-block playground-block" data-level="4">
                <div class="block-header">
                    <h3>üî¨ Advanced Popper Simulator</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="popper-intro-note">
                        <strong>Interactive Hypothesis Space Exploration:</strong> Watch Popper traverse the hypothesis lattice, 
                        learning constraints from failures, and see how cutting-edge optimizations from REDUCER, Symmetry Breaking, 
                        and MAXREFACTOR integrate into the search process.
                    </div>
                    
                    <div class="advanced-popper-simulator" id="advancedPopperSimulator">
                        <!-- Top Row: Task Definition + Research Integration -->
                        <div class="simulator-top-row">
                            <div class="task-definition-panel">
                                <h4>üìã Learning Task: grandparent/2</h4>
                                <div class="task-details">
                                    <div class="task-section bk-section">
                                        <span class="section-label">Background Knowledge</span>
                                        <div class="facts-display">
                                            <span class="fact">parent(ann,bob)</span>
                                            <span class="fact">parent(bob,carol)</span>
                                            <span class="fact">parent(bob,dave)</span>
                                            <span class="fact">parent(carol,eve)</span>
                                        </div>
                                    </div>
                                    <div class="task-section examples-section">
                                        <div class="example-group positive">
                                            <span class="group-label">E‚Å∫</span>
                                            <span class="example">grandparent(ann,carol)</span>
                                            <span class="example">grandparent(ann,dave)</span>
                                            <span class="example">grandparent(bob,eve)</span>
                                        </div>
                                        <div class="example-group negative">
                                            <span class="group-label">E‚Åª</span>
                                            <span class="example">grandparent(ann,bob)</span>
                                            <span class="example">grandparent(carol,ann)</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="research-integration-panel">
                                <h4>üî¨ Research Optimizations Active</h4>
                                <div class="optimization-toggles">
                                    <label class="toggle-item active" data-opt="reducer">
                                        <input type="checkbox" id="optReducer" checked>
                                        <span class="toggle-name">REDUCER</span>
                                        <span class="toggle-desc">Prune pointless rules</span>
                                        <span class="toggle-stat" id="reducerStat">0 pruned</span>
                                    </label>
                                    <label class="toggle-item active" data-opt="symmetry">
                                        <input type="checkbox" id="optSymmetry" checked>
                                        <span class="toggle-name">Symmetry Breaking</span>
                                        <span class="toggle-desc">Eliminate body-variants</span>
                                        <span class="toggle-stat" id="symmetryStat">0 pruned</span>
                                    </label>
                                    <label class="toggle-item" data-opt="refactor">
                                        <input type="checkbox" id="optRefactor">
                                        <span class="toggle-name">MAXREFACTOR</span>
                                        <span class="toggle-desc">Compress final program</span>
                                        <span class="toggle-stat" id="refactorStat">Ready</span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Main Visualization Area -->
                        <div class="simulator-main-area">
                            <!-- Hypothesis Lattice Graph -->
                            <div class="lattice-visualization">
                                <h4>Hypothesis Lattice (Generality Ordering)</h4>
                                <div class="lattice-container">
                                    <canvas id="hypothesisLatticeCanvas" width="800" height="500"></canvas>
                                </div>
                                <div class="lattice-legend">
                                    <div class="legend-item"><span class="node-sample unexplored"></span> Unexplored</div>
                                    <div class="legend-item"><span class="node-sample current"></span> Current</div>
                                    <div class="legend-item"><span class="node-sample tested"></span> Tested</div>
                                    <div class="legend-item"><span class="node-sample too-general"></span> Too General</div>
                                    <div class="legend-item"><span class="node-sample too-specific"></span> Too Specific</div>
                                    <div class="legend-item"><span class="node-sample pruned-reducer"></span> REDUCER Pruned</div>
                                    <div class="legend-item"><span class="node-sample pruned-symmetry"></span> Symmetry Pruned</div>
                                    <div class="legend-item"><span class="node-sample solution"></span> Solution</div>
                                </div>
                            </div>

                            <!-- Right Panel: Stats + Current State -->
                            <div class="simulator-right-panel">
                                <!-- Current Hypothesis Display -->
                                <div class="current-hypothesis-panel">
                                    <h4>Current Hypothesis</h4>
                                    <div class="hypothesis-display" id="currentHypDisplay">
                                        <div class="hyp-empty">Click "Step" to begin exploration</div>
                                    </div>
                                    <div class="hypothesis-evaluation" id="hypEvaluation">
                                        <div class="eval-row">
                                            <span class="eval-label">Covers E‚Å∫:</span>
                                            <span class="eval-value" id="evalPosCount">‚Äî</span>
                                        </div>
                                        <div class="eval-row">
                                            <span class="eval-label">Covers E‚Åª:</span>
                                            <span class="eval-value" id="evalNegCount">‚Äî</span>
                                        </div>
                                        <div class="eval-row">
                                            <span class="eval-label">Status:</span>
                                            <span class="eval-status" id="evalStatus">Waiting</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Statistics Dashboard -->
                                <div class="stats-dashboard">
                                    <h4>Search Statistics</h4>
                                    <div class="stats-grid">
                                        <div class="stat-card">
                                            <div class="stat-value" id="statHypTested">0</div>
                                            <div class="stat-label">Hypotheses Tested</div>
                                        </div>
                                        <div class="stat-card">
                                            <div class="stat-value" id="statConstraints">0</div>
                                            <div class="stat-label">Constraints Learned</div>
                                        </div>
                                        <div class="stat-card highlight">
                                            <div class="stat-value" id="statPruned">0%</div>
                                            <div class="stat-label">Space Pruned</div>
                                        </div>
                                        <div class="stat-card">
                                            <div class="stat-value" id="statRemaining">64</div>
                                            <div class="stat-label">Hypotheses Remaining</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Pruning Breakdown -->
                                    <div class="pruning-breakdown">
                                        <h5>Pruning Breakdown</h5>
                                        <div class="breakdown-bars">
                                            <div class="breakdown-row">
                                                <span class="breakdown-label">Generalization</span>
                                                <div class="breakdown-bar-container">
                                                    <div class="breakdown-bar gen" id="barGen" style="width: 0%"></div>
                                                </div>
                                                <span class="breakdown-value" id="valGen">0</span>
                                            </div>
                                            <div class="breakdown-row">
                                                <span class="breakdown-label">Specialization</span>
                                                <div class="breakdown-bar-container">
                                                    <div class="breakdown-bar spec" id="barSpec" style="width: 0%"></div>
                                                </div>
                                                <span class="breakdown-value" id="valSpec">0</span>
                                            </div>
                                            <div class="breakdown-row">
                                                <span class="breakdown-label">REDUCER</span>
                                                <div class="breakdown-bar-container">
                                                    <div class="breakdown-bar reducer" id="barReducer" style="width: 0%"></div>
                                                </div>
                                                <span class="breakdown-value" id="valReducer">0</span>
                                            </div>
                                            <div class="breakdown-row">
                                                <span class="breakdown-label">Symmetry</span>
                                                <div class="breakdown-bar-container">
                                                    <div class="breakdown-bar symmetry" id="barSymmetry" style="width: 0%"></div>
                                                </div>
                                                <span class="breakdown-value" id="valSymmetry">0</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Learned Constraints -->
                                <div class="constraints-panel">
                                    <h4>Learned Constraints</h4>
                                    <div class="constraints-list" id="constraintsList">
                                        <div class="constraint-empty">No constraints yet</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Controls and Timeline -->
                        <div class="simulator-bottom-row">
                            <div class="control-panel">
                                <div class="control-buttons">
                                    <button class="sim-btn primary" id="btnSimStep" onclick="advancedSimStep()">
                                        <span class="btn-icon">‚ñ∂</span> Step
                                    </button>
                                    <button class="sim-btn" id="btnSimRun" onclick="advancedSimRun()">
                                        <span class="btn-icon">‚è©</span> Auto Run
                                    </button>
                                    <button class="sim-btn" id="btnSimPause" onclick="advancedSimPause()" style="display:none;">
                                        <span class="btn-icon">‚è∏</span> Pause
                                    </button>
                                    <button class="sim-btn danger" onclick="advancedSimReset()">
                                        <span class="btn-icon">‚Ü∫</span> Reset
                                    </button>
                                </div>
                                <div class="speed-control">
                                    <label>Speed:</label>
                                    <input type="range" id="simSpeedSlider" min="50" max="1500" value="500">
                                    <span id="speedLabel">500ms</span>
                                </div>
                            </div>
                            
                            <!-- Execution Log -->
                            <div class="execution-log-panel">
                                <h4>Execution Log</h4>
                                <div class="execution-log" id="executionLog">
                                    <div class="log-entry info">
                                        <span class="log-step">‚Äî</span>
                                        <span class="log-msg">Popper simulator initialized. Hypothesis space contains 64 candidate rules.</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Solution Display (Hidden until found) -->
                        <div class="solution-panel" id="solutionPanel" style="display: none;">
                            <div class="solution-header">
                                <span class="solution-icon">üéâ</span>
                                <h4>Solution Found!</h4>
                            </div>
                            <div class="solution-content">
                                <pre class="solution-code" id="solutionCode"></pre>
                                <div class="solution-stats">
                                    <span>Found in <strong id="solutionSteps">0</strong> steps</span>
                                    <span>Pruned <strong id="solutionPruned">0%</strong> of search space</span>
                                </div>
                            </div>
                            <div class="refactor-section" id="refactorSection" style="display: none;">
                                <h5>MAXREFACTOR Compression:</h5>
                                <pre class="refactored-code" id="refactoredCode"></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: Research -->
        <section id="research" class="section">
            <div class="section-header">
                <span class="section-number">06</span>
                <h2 class="section-title">Research Frontiers</h2>
                <p class="section-desc">Current challenges and future directions in ILP research</p>
            </div>

            <!-- Research Challenges -->
            <div class="content-block" data-level="4">
                <div class="block-header">
                    <h3>Open Research Problems</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="research-problems">
                        <div class="problem-card">
                            <div class="problem-header">
                                <span class="problem-icon">üß©</span>
                                <h4>Predicate Invention</h4>
                            </div>
                            <div class="problem-body">
                                <p><strong>Challenge:</strong> Automatically introducing new predicates not in the initial vocabulary.</p>
                                <p><strong>Why Hard:</strong> Exponentially increases hypothesis space. No clear guidance on what to invent.</p>
                                <p><strong>Current Approaches:</strong> Meta-interpretive learning, abstraction refinement, neural-guided invention.</p>
                            </div>
                        </div>

                        <div class="problem-card">
                            <div class="problem-header">
                                <span class="problem-icon">üîÅ</span>
                                <h4>Learning Recursion</h4>
                            </div>
                            <div class="problem-body">
                                <p><strong>Challenge:</strong> Inducing recursive definitions from finite examples.</p>
                                <p><strong>Why Hard:</strong> Undecidable in general. Infinite behaviors from finite observations.</p>
                                <p><strong>Current Approaches:</strong> Bounded recursion, meta-rules, trace-based learning.</p>
                            </div>
                        </div>

                        <div class="problem-card">
                            <div class="problem-header">
                                <span class="problem-icon">üìà</span>
                                <h4>Scalability</h4>
                            </div>
                            <div class="problem-body">
                                <p><strong>Challenge:</strong> Handling large datasets and complex hypothesis spaces.</p>
                                <p><strong>Why Hard:</strong> Combinatorial explosion in hypothesis enumeration.</p>
                                <p><strong>Current Approaches:</strong> Constraint learning, parallel search, neural guidance.</p>
                            </div>
                        </div>

                        <div class="problem-card">
                            <div class="problem-header">
                                <span class="problem-icon">üé≤</span>
                                <h4>Noise Tolerance</h4>
                            </div>
                            <div class="problem-body">
                                <p><strong>Challenge:</strong> Learning from mislabeled or incomplete examples.</p>
                                <p><strong>Why Hard:</strong> Must distinguish noise from genuine exceptions.</p>
                                <p><strong>Current Approaches:</strong> MaxSAT optimization, probabilistic ILP, brave/cautious semantics.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Neuro-Symbolic Integration -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>Neuro-Symbolic Integration</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="neurosymbolic">
                        <div class="integration-diagram">
                            <h4>Integration Architectures</h4>
                            <div class="architecture-comparison">
                                <div class="arch-card">
                                    <h5>Neural ‚Üí Symbolic</h5>
                                    <div class="arch-diagram">
                                        <div class="arch-node neural">Neural Perception</div>
                                        <div class="arch-arrow">‚Üì</div>
                                        <div class="arch-node symbolic">Symbolic Reasoning</div>
                                    </div>
                                    <p>Use neural networks for perception, ILP for reasoning</p>
                                    <span class="example">DeepProbLog, NeurASP</span>
                                </div>
                                <div class="arch-card">
                                    <h5>Symbolic ‚Üí Neural</h5>
                                    <div class="arch-diagram">
                                        <div class="arch-node symbolic">Symbolic Structure</div>
                                        <div class="arch-arrow">‚Üì</div>
                                        <div class="arch-node neural">Neural Parameters</div>
                                    </div>
                                    <p>Use symbolic structure with learnable weights</p>
                                    <span class="example">Neural Theorem Provers</span>
                                </div>
                                <div class="arch-card">
                                    <h5>Neural ‚Üî Symbolic</h5>
                                    <div class="arch-diagram">
                                        <div class="arch-node hybrid">Differentiable ILP</div>
                                    </div>
                                    <p>End-to-end differentiable rule learning</p>
                                    <span class="example">‚àÇILP, DILP</span>
                                </div>
                            </div>
                        </div>

                        <div class="comparison-table-section">
                            <h4>Neural vs Symbolic vs Neuro-Symbolic</h4>
                            <table class="comparison-table">
                                <thead>
                                    <tr>
                                        <th>Aspect</th>
                                        <th>Neural</th>
                                        <th>Symbolic (ILP)</th>
                                        <th>Neuro-Symbolic</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Data Efficiency</td>
                                        <td class="rating low">Low</td>
                                        <td class="rating high">High</td>
                                        <td class="rating high">High</td>
                                    </tr>
                                    <tr>
                                        <td>Interpretability</td>
                                        <td class="rating low">Low</td>
                                        <td class="rating high">High</td>
                                        <td class="rating medium">Medium-High</td>
                                    </tr>
                                    <tr>
                                        <td>Perception</td>
                                        <td class="rating high">High</td>
                                        <td class="rating low">Low</td>
                                        <td class="rating high">High</td>
                                    </tr>
                                    <tr>
                                        <td>Generalization</td>
                                        <td class="rating low">In-distribution</td>
                                        <td class="rating high">Compositional</td>
                                        <td class="rating high">Compositional</td>
                                    </tr>
                                    <tr>
                                        <td>Scalability</td>
                                        <td class="rating high">High</td>
                                        <td class="rating medium">Medium</td>
                                        <td class="rating medium">Medium</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PhD Research Directions -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>Potential PhD Research Directions</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="research-directions">
                        <div class="direction-card">
                            <div class="direction-number">1</div>
                            <div class="direction-content">
                                <h4>Efficient Hypothesis Search via Learned Constraints</h4>
                                <p>Develop new constraint learning strategies that provide stronger pruning guarantees while maintaining completeness.</p>
                                <div class="direction-tags">
                                    <span class="tag">Popper Extension</span>
                                    <span class="tag">Constraint Optimization</span>
                                </div>
                            </div>
                        </div>

                        <div class="direction-card">
                            <div class="direction-number">2</div>
                            <div class="direction-content">
                                <h4>Neural-Guided Predicate Invention</h4>
                                <p>Use neural networks to guide the invention of useful predicates, reducing the search space while maintaining expressiveness.</p>
                                <div class="direction-tags">
                                    <span class="tag">Neuro-Symbolic</span>
                                    <span class="tag">Meta-Learning</span>
                                </div>
                            </div>
                        </div>

                        <div class="direction-card">
                            <div class="direction-number">3</div>
                            <div class="direction-content">
                                <h4>ILP for Program Repair</h4>
                                <p>Apply ILP techniques to automatically learn bug-fixing patterns from code repositories.</p>
                                <div class="direction-tags">
                                    <span class="tag">Software Engineering</span>
                                    <span class="tag">Program Synthesis</span>
                                </div>
                            </div>
                        </div>

                        <div class="direction-card">
                            <div class="direction-number">4</div>
                            <div class="direction-content">
                                <h4>Incremental ILP for Streaming Data</h4>
                                <p>Develop ILP systems that can efficiently update hypotheses as new examples arrive.</p>
                                <div class="direction-tags">
                                    <span class="tag">Online Learning</span>
                                    <span class="tag">Theory Revision</span>
                                </div>
                            </div>
                        </div>

                        <div class="direction-card">
                            <div class="direction-number">5</div>
                            <div class="direction-content">
                                <h4>Explainable AI via Rule Learning</h4>
                                <p>Use ILP to extract interpretable rules that explain black-box model predictions.</p>
                                <div class="direction-tags">
                                    <span class="tag">XAI</span>
                                    <span class="tag">Model Interpretation</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Key Papers -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>Essential Reading</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="papers-list">
                        <div class="paper-card">
                            <div class="paper-year">1994</div>
                            <div class="paper-content">
                                <h5>Inductive Logic Programming: Theory and Methods</h5>
                                <p class="paper-authors">Muggleton & De Raedt</p>
                                <p class="paper-venue">Journal of Logic Programming</p>
                                <span class="paper-type foundational">Foundational</span>
                            </div>
                        </div>

                        <div class="paper-card">
                            <div class="paper-year">2021</div>
                            <div class="paper-content">
                                <h5>Learning Programs by Learning from Failures</h5>
                                <p class="paper-authors">Cropper & Morel</p>
                                <p class="paper-venue">Machine Learning</p>
                                <span class="paper-type state-of-art">State-of-Art</span>
                            </div>
                        </div>

                        <div class="paper-card">
                            <div class="paper-year">2022</div>
                            <div class="paper-content">
                                <h5>Turning 30: New Ideas in Inductive Logic Programming</h5>
                                <p class="paper-authors">Cropper, Dumanƒçiƒá & Muggleton</p>
                                <p class="paper-venue">IJCAI Survey Track</p>
                                <span class="paper-type survey">Survey</span>
                            </div>
                        </div>

                        <div class="paper-card">
                            <div class="paper-year">2018</div>
                            <div class="paper-content">
                                <h5>Learning Explanatory Rules from Noisy Data</h5>
                                <p class="paper-authors">Evans & Grefenstette</p>
                                <p class="paper-venue">JAIR</p>
                                <span class="paper-type neuro-symbolic">Neuro-Symbolic</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Advanced Research - Cutting-Edge ILP Innovations -->
        <section id="advanced-research" class="section">
            <div class="section-header">
                <span class="section-number">07</span>
                <h2 class="section-title">Advanced Research</h2>
                <p class="section-desc">Cutting-edge innovations from the Logic and Learning Lab (2024-2025)</p>
            </div>

            <!-- Research Overview -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>Four Pillars of Modern ILP Advancement</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="research-overview">
                        <p class="overview-intro">
                            Recent research from Andrew Cropper's group addresses fundamental challenges in ILP through four complementary approaches: 
                            <strong>knowledge compression</strong>, <strong>hypothesis space pruning</strong>, <strong>symmetry elimination</strong>, 
                            and <strong>human-machine teaching dynamics</strong>. Together, these innovations achieve order-of-magnitude improvements 
                            in learning efficiency.
                        </p>
                        
                        <div class="research-pillars">
                            <div class="pillar-card" data-paper="maxrefactor">
                                <div class="pillar-icon">üîÑ</div>
                                <h4>MAXREFACTOR</h4>
                                <p class="pillar-tagline">Scalable Knowledge Refactoring</p>
                                <div class="pillar-stats">
                                    <span class="stat"><strong>60%</strong> better compression</span>
                                    <span class="stat"><strong>O(nk)</strong> vs O(n¬∑2·µè)</span>
                                </div>
                            </div>
                            
                            <div class="pillar-card" data-paper="reducer">
                                <div class="pillar-icon">‚úÇÔ∏è</div>
                                <h4>REDUCER</h4>
                                <p class="pillar-tagline">Pruning Pointless Rules</p>
                                <div class="pillar-stats">
                                    <span class="stat"><strong>99%</strong> time reduction</span>
                                    <span class="stat"><strong>2%</strong> overhead</span>
                                </div>
                            </div>
                            
                            <div class="pillar-card" data-paper="symmetry">
                                <div class="pillar-icon">‚öñÔ∏è</div>
                                <h4>Symmetry Breaking</h4>
                                <p class="pillar-tagline">Eliminating Equivalent Hypotheses</p>
                                <div class="pillar-stats">
                                    <span class="stat"><strong>99.5%</strong> solving reduction</span>
                                    <span class="stat"><strong>GI-hard</strong> foundation</span>
                                </div>
                            </div>
                            
                            <div class="pillar-card" data-paper="human-teaching">
                                <div class="pillar-icon">üë§</div>
                                <h4>Human Teaching</h4>
                                <p class="pillar-tagline">Can Humans Teach Machines?</p>
                                <div class="pillar-stats">
                                    <span class="stat"><strong>Negative</strong> result</span>
                                    <span class="stat"><strong>Random</strong> beats humans</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- MAXREFACTOR: Knowledge Refactoring -->
            <div class="content-block paper-deep-dive" data-level="5" id="maxrefactor-section">
                <div class="block-header">
                    <h3>MAXREFACTOR: Scalable Knowledge Refactoring via Constrained Optimisation</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="paper-citation">
                        <span class="citation-authors">Liu, Cerna, Gouveia & Cropper (2024)</span>
                        <span class="citation-venue">arXiv:2408.11530</span>
                    </div>

                    <div class="concept-explanation">
                        <h4>The Refactoring Problem</h4>
                        <p>
                            Knowledge refactoring compresses a logic program by introducing new <em>invented rules</em>. 
                            This is crucial for policy reuse in planning and improving program synthesis performance.
                            The challenge: finding optimal compressions is computationally hard.
                        </p>
                    </div>

                    <!-- Interactive Refactoring Demo -->
                    <div class="refactoring-demo">
                        <h4>Live Example: Program Compression</h4>
                        <div class="demo-grid">
                            <div class="demo-panel original">
                                <h5>Original Program P‚ÇÅ (20 literals)</h5>
                                <pre class="code-block">
g(A) ‚Üê p(A), q(A,B), r(B), s(A,B)
g(A) ‚Üê p(A), q(A,B), r(B), t(A,B)
g(A) ‚Üê p(B), q(B,C), r(C), w(A,B)
g(A) ‚Üê p(A), q(B,A), r(A), z(A,B)</pre>
                            </div>
                            <div class="demo-arrow">‚Üí</div>
                            <div class="demo-panel refactored">
                                <h5>Refactored Program P‚ÇÉ (16 literals)</h5>
                                <pre class="code-block">
<span class="invented">aux‚ÇÇ(A,B,C) ‚Üê p(A), q(B,C), r(C)</span>
g(A) ‚Üê aux‚ÇÇ(A,A,B), s(A,B)
g(A) ‚Üê aux‚ÇÇ(A,A,B), t(A,B)
g(A) ‚Üê aux‚ÇÇ(B,B,C), w(A,B)
g(A) ‚Üê aux‚ÇÇ(A,B,A), z(A,B)</pre>
                            </div>
                        </div>
                        <div class="demo-insight">
                            <strong>Key Insight:</strong> The invented rule aux‚ÇÇ is NOT a subset of any original rule‚Äîit uses 
                            variables in a novel configuration (A,B,C) that allows all four rules to be refactored. 
                            Previous approaches like KNORF couldn't find this solution.
                        </div>
                    </div>

                    <!-- Technical Innovation -->
                    <div class="technical-section">
                        <h4>Technical Innovations</h4>
                        
                        <div class="innovation-grid">
                            <div class="innovation-card">
                                <h5>1. Literal-Based Decision Variables</h5>
                                <div class="complexity-comparison">
                                    <div class="complexity-item old">
                                        <span class="approach">KNORF</span>
                                        <span class="formula">O(n ¬∑ 2·µè)</span>
                                        <span class="explanation">Enumerate all subsets of rules</span>
                                    </div>
                                    <div class="complexity-item new">
                                        <span class="approach">MAXREFACTOR</span>
                                        <span class="formula">O(n ¬∑ k)</span>
                                        <span class="explanation">Decision per literal position</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="innovation-card">
                                <h5>2. Linear Invented Rules</h5>
                                <p>Variables occur linearly in body literals‚Äîno shared variables between body atoms.</p>
                                <div class="theorem-box">
                                    <strong>Theorem 2:</strong> If an optimal solution exists using invented rules C ‚äÜ S, 
                                    then an equivalent solution exists using C‚Ä≤ ‚äÜ S<sub>lin</sub> (linear rules only).
                                </div>
                            </div>
                            
                            <div class="innovation-card">
                                <h5>3. COP Encoding</h5>
                                <p>Decision variables: r<sub>k,p</sub> (# literals with predicate p in rule k), 
                                   use<sup>t</sup><sub>c,k</sub> (rule c uses invented rule k t times), 
                                   cover<sup>t</sup><sub>c,a,k</sub> (literal a covered by k)</p>
                            </div>
                        </div>
                    </div>

                    <!-- Complexity Result -->
                    <div class="complexity-result">
                        <h4>Complexity Analysis</h4>
                        <div class="theorem-box major">
                            <strong>Theorem 1 (NP-Hardness):</strong> The optimal knowledge refactoring problem is NP-hard.
                            <div class="proof-sketch">
                                <strong>Proof sketch:</strong> Reduction from Maximum Independent Set in 3-regular Hamiltonian graphs. 
                                Optimal refactorings of instances derived from such graphs are always supersets of a maximum independent set.
                            </div>
                        </div>
                    </div>

                    <!-- Experimental Results -->
                    <div class="experimental-results">
                        <h4>Empirical Results</h4>
                        <div class="results-grid">
                            <div class="result-card">
                                <div class="result-value">60%</div>
                                <div class="result-label">Better compression on Strings dataset</div>
                                <div class="result-detail">vs KNORF baseline</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">27%+</div>
                                <div class="result-label">Improvement across all Lego programs</div>
                                <div class="result-detail">Minimum improvement</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">1000</div>
                                <div class="result-label">Program size scalability</div>
                                <div class="result-detail">On WordNet dataset</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- REDUCER: Pointless Rules -->
            <div class="content-block paper-deep-dive" data-level="5" id="reducer-section">
                <div class="block-header">
                    <h3>REDUCER: Efficient Rule Induction by Ignoring Pointless Rules</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="paper-citation">
                        <span class="citation-authors">Cropper & Cerna (2025)</span>
                        <span class="citation-venue">arXiv:2502.01232</span>
                    </div>

                    <div class="concept-explanation">
                        <h4>The Core Insight</h4>
                        <p>
                            Many rules in the hypothesis space are <em>pointless</em>‚Äîthey can never appear in an optimal hypothesis. 
                            REDUCER identifies two types of pointless rules and proves that ignoring them soundly prunes the search space.
                        </p>
                    </div>

                    <!-- Pointless Rule Types -->
                    <div class="pointless-types">
                        <div class="type-card reducible">
                            <h5>Reducible Rules</h5>
                            <div class="definition">
                                A rule is <strong>reducible</strong> if it contains a body literal implied by other body literals.
                            </div>
                            <div class="example-box">
                                <strong>Example:</strong>
                                <pre class="code-block small">
r‚ÇÅ = f(A) ‚Üê odd(A), int(A)    // Reducible!
r‚ÇÇ = f(A) ‚Üê odd(A)            // Equivalent</pre>
                                <p class="explanation">Since odd(A) implies int(A), the literal int(A) is redundant.</p>
                            </div>
                            <div class="example-box">
                                <strong>Transitive Example:</strong>
                                <pre class="code-block small">
h ‚Üê gt(A,B), gt(B,C), gt(A,C)  // Reducible!</pre>
                                <p class="explanation">gt/2 is transitive, so gt(A,C) is implied by the first two literals.</p>
                            </div>
                        </div>

                        <div class="type-card indiscriminate">
                            <h5>Indiscriminate Rules</h5>
                            <div class="definition">
                                A rule is <strong>indiscriminate</strong> if it contains a literal that is true for all negative examples 
                                (cannot discriminate against them).
                            </div>
                            <div class="example-box">
                                <strong>Example:</strong>
                                <pre class="code-block small">
E‚Åª = {f(1), f(2), f(3)}
f(A) ‚Üê odd(A), lt(A,10)  // Indiscriminate!</pre>
                                <p class="explanation">The literal lt(A,10) is true for ALL negative examples, so it's useless for discrimination.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Captured Literals -->
                    <div class="captured-concept">
                        <h4>The Key Concept: Captured Literals</h4>
                        <div class="definition-box">
                            <strong>Definition 7 (Captured Literal):</strong> A literal l is <em>r-captured</em> if all its variables 
                            appear elsewhere in the rule (in the head or other body literals).
                        </div>
                        <div class="captured-example">
                            <pre class="code-block">
h ‚Üê succ(A,B), succ(B,C), <span class="captured">gt(C,A)</span>, gt(C,D)</pre>
                            <p class="explanation">
                                <span class="captured">gt(C,A)</span> is captured (C and A appear elsewhere), but gt(C,D) is NOT captured (D is unique).
                            </p>
                        </div>
                        <div class="theorem-box">
                            <strong>Lemma 1:</strong> If a literal is captured in a rule, it remains captured in all specializations 
                            (adding more literals preserves or creates capture).
                        </div>
                    </div>

                    <!-- Propositions -->
                    <div class="propositions-section">
                        <h4>Theoretical Foundations</h4>
                        <div class="proposition-grid">
                            <div class="proposition-card">
                                <h5>Proposition 1 (Reducible Specializations)</h5>
                                <p>If r‚ÇÅ is reducible and r‚ÇÅ ‚äÜ r‚ÇÇ (r‚ÇÇ is a specialization), then r‚ÇÇ is also reducible.</p>
                                <p class="implication"><strong>Implication:</strong> We can prune ALL specializations of a reducible rule.</p>
                            </div>
                            <div class="proposition-card">
                                <h5>Proposition 3 (Indiscriminate Specializations)</h5>
                                <p>If r‚ÇÅ is indiscriminate and r‚ÇÅ ‚äÜ r‚ÇÇ, then r‚ÇÇ is also indiscriminate.</p>
                                <p class="implication"><strong>Implication:</strong> We can prune ALL specializations of an indiscriminate rule.</p>
                            </div>
                            <div class="proposition-card full-width">
                                <h5>Corollary 1 (Soundness)</h5>
                                <p>A pointless hypothesis (containing a reducible or indiscriminate rule) is NEVER optimal.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Interactive Demo -->
                    <div class="pointless-demo">
                        <h4>Interactive: Pointless Rule Detector</h4>
                        <div class="detector-container">
                            <div class="detector-input">
                                <label>Background Knowledge:</label>
                                <div class="bk-facts">
                                    <span class="fact active" data-fact="odd-implies-int">odd(X) ‚Üí int(X)</span>
                                    <span class="fact active" data-fact="gt-transitive">gt transitive</span>
                                </div>
                                <label>Test Rule:</label>
                                <div class="rule-display" id="test-rule">
                                    f(A) ‚Üê <span class="literal" data-lit="odd">odd(A)</span>, <span class="literal" data-lit="int">int(A)</span>, <span class="literal" data-lit="gt">gt(A,3)</span>
                                </div>
                            </div>
                            <div class="detector-result">
                                <div class="result-indicator reducible-detected">
                                    <span class="icon">‚ö†Ô∏è</span>
                                    <span class="text">REDUCIBLE: int(A) is implied by odd(A)</span>
                                </div>
                            </div>
                            <button class="btn-secondary" onclick="toggleLiteral('int')">Toggle int(A)</button>
                        </div>
                    </div>

                    <!-- Algorithm -->
                    <div class="algorithm-section">
                        <h4>Algorithm 2: Finding Pointless Rules</h4>
                        <pre class="code-block algorithm">
<span class="keyword">def</span> pointless(h, neg, bk):
    <span class="keyword">for</span> rule <span class="keyword">in</span> h:
        <span class="keyword">if not</span> basic(rule, h):  <span class="comment"># Skip recursive predicates</span>
            <span class="keyword">continue</span>
        head, body = rule
        <span class="keyword">for</span> literal <span class="keyword">in</span> body:
            body‚Ä≤ = body - literal
            <span class="keyword">if not</span> captured(head, body‚Ä≤, literal):
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="highlight">reducible(bk, body‚Ä≤, literal)</span>:
                <span class="keyword">return</span> <span class="const">True</span>
            <span class="keyword">if</span> <span class="highlight">indiscriminate(bk, neg, rule, head, body‚Ä≤)</span>:
                <span class="keyword">return</span> <span class="const">True</span>
    <span class="keyword">return</span> <span class="const">False</span></pre>
                    </div>

                    <!-- Results -->
                    <div class="experimental-results">
                        <h4>Empirical Impact</h4>
                        <div class="results-grid">
                            <div class="result-card highlight">
                                <div class="result-value">99%</div>
                                <div class="result-label">Learning time reduction</div>
                                <div class="result-detail">Eight-puzzle: 60min ‚Üí 12sec</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">21%</div>
                                <div class="result-label">Tasks with significant speedup</div>
                                <div class="result-detail">96/449 tasks improved</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">2%</div>
                                <div class="result-label">Mean overhead</div>
                                <div class="result-detail">Cost of detection is minimal</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Symmetry Breaking -->
            <div class="content-block paper-deep-dive" data-level="5" id="symmetry-section">
                <div class="block-header">
                    <h3>Symmetry Breaking for Inductive Logic Programming</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="paper-citation">
                        <span class="citation-authors">Cropper, Cerna & J√§rvisalo (2025)</span>
                        <span class="citation-venue">arXiv:2508.06263</span>
                    </div>

                    <div class="concept-explanation">
                        <h4>The Symmetry Problem</h4>
                        <p>
                            ILP hypothesis spaces contain many <em>logically equivalent</em> hypotheses that differ only in variable naming.
                            This causes solvers to redundantly explore symmetric search branches.
                        </p>
                    </div>

                    <!-- Body Variant Example -->
                    <div class="symmetry-example">
                        <h4>Example: Body-Variant Rules</h4>
                        <div class="variant-comparison">
                            <div class="variant-rule">
                                <h5>Rule r‚ÇÅ</h5>
                                <pre class="code-block">zendo(A) ‚Üê piece(A,B), size(B,C), 
           blue(B), small(C)</pre>
                            </div>
                            <div class="variant-equals">‚â°</div>
                            <div class="variant-rule">
                                <h5>Rule r‚ÇÇ</h5>
                                <pre class="code-block">zendo(A) ‚Üê piece(A,C), size(C,B), 
           blue(C), small(B)</pre>
                            </div>
                        </div>
                        <div class="substitution-note">
                            <strong>Substitution:</strong> r‚ÇÅ = r‚ÇÇŒ∏ where Œ∏ = {C ‚Ü¶ B, B ‚Ü¶ C}
                        </div>
                    </div>

                    <!-- Complexity Result -->
                    <div class="complexity-result">
                        <h4>Hardness Result</h4>
                        <div class="theorem-box major">
                            <strong>Proposition 1 (Body-Variant Hardness):</strong> The body-variant problem is GI-hard 
                            (Graph Isomorphism hard).
                            <div class="proof-sketch">
                                <strong>Proof idea:</strong> Encode a graph G = (N, E) as a rule using edge/2 predicates and |N| variables.
                                Graph isomorphism reduces to determining if two such rules are body-variants.
                            </div>
                        </div>
                        <p class="hardness-implication">
                            This motivates developing <em>incomplete but tractable</em> symmetry-breaking approaches.
                        </p>
                    </div>

                    <!-- Safe Variables -->
                    <div class="ordering-concepts">
                        <h4>The Solution: Variable Ordering & Safe Variables</h4>
                        
                        <div class="concept-grid">
                            <div class="concept-card">
                                <h5>Skipped Variables</h5>
                                <p>A variable x is <em>skipped</em> in literal l if l contains variables both larger and smaller than x (in the ordering), but not x itself.</p>
                                <div class="example-mini">
                                    <code>pre_pad‚ÇÇ(p(A,E)) ‚Üí skipped = {B,C,D}</code>
                                </div>
                            </div>
                            
                            <div class="concept-card">
                                <h5>Witnessed Variables</h5>
                                <p>A skipped variable x is <em>witnessed</em> if x appears in a lexicographically smaller literal.</p>
                            </div>
                            
                            <div class="concept-card">
                                <h5>Safe Variables</h5>
                                <p>A variable is <em>safe</em> if every time it's skipped, it's also witnessed by a smaller literal.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Rule Analysis -->
                    <div class="rule-analysis">
                        <h4>Example Analysis</h4>
                        <div class="analysis-comparison">
                            <div class="analysis-item unsafe">
                                <h5>Rule r‚ÇÇ (UNSAFE - Pruned)</h5>
                                <pre class="code-block small">h(A,B) ‚Üê p(A,E), p(B,C), p(C,D)</pre>
                                <ul class="analysis-steps">
                                    <li>p(A,E) skips {B,C,D}</li>
                                    <li>C and D not witnessed by smaller literals</li>
                                    <li><strong class="unsafe-marker">D is unsafe ‚Üí Prune!</strong></li>
                                </ul>
                            </div>
                            <div class="analysis-item safe">
                                <h5>Rule r‚ÇÉ (SAFE - Keep)</h5>
                                <pre class="code-block small">h(A,B) ‚Üê p(A,C), p(B,D), p(C,E)</pre>
                                <ul class="analysis-steps">
                                    <li>p(C,E) skips D</li>
                                    <li>D witnessed by p(B,D)</li>
                                    <li>p(B,D) &lt;<sub>lex</sub> p(C,E) ‚úì</li>
                                    <li><strong class="safe-marker">All variables safe ‚Üí Keep!</strong></li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Soundness Theorem -->
                    <div class="theorem-section">
                        <h4>Theoretical Guarantee</h4>
                        <div class="theorem-box major">
                            <strong>Proposition 2 (Soundness):</strong> For every rule r, there exists a body-variant r‚Ä≤ 
                            such that all variables in r‚Ä≤ are safe.
                            <p class="theorem-implication">
                                <strong>Implication:</strong> We can prune all unsafe rules without losing optimal hypotheses.
                            </p>
                        </div>
                    </div>

                    <!-- ASP Implementation -->
                    <div class="implementation-section">
                        <h4>ASP Implementation</h4>
                        <pre class="code-block asp">
<span class="comment">% Identify ordered variables for body literals</span>
appears(Rule, OrderedVars) :-
    blit(Rule, _, Vars), 
    padded_vars(Vars, PaddedVars),
    ordered_vars(PaddedVars, OrderedVars).

<span class="comment">% Check if a variable is witnessed</span>
witnessed(Rule, V, Vars1) :-
    appears(Rule, Vars1), skipped(Vars1, V),
    lower(Vars2, Vars1), var_member(V, Vars2),
    appears(Rule, Vars2).

<span class="comment">% Constraint: prune rules with unsafe variables</span>
:- body_var(Rule, V), appears(Rule, Vars),
   skipped(Vars, V), <span class="highlight">not witnessed(Rule, V, Vars)</span>.</pre>
                    </div>

                    <!-- Scalability Chart -->
                    <div class="scalability-section">
                        <h4>Scalability Analysis</h4>
                        <div class="chart-container">
                            <canvas id="symmetry-scalability-chart"></canvas>
                        </div>
                        <p class="chart-caption">
                            Solving time comparison: Without symmetry breaking, 9 variables takes &gt;60 minutes. 
                            With symmetry breaking: only 17 seconds.
                        </p>
                    </div>

                    <!-- Results -->
                    <div class="experimental-results">
                        <h4>Experimental Results</h4>
                        <div class="results-grid">
                            <div class="result-card highlight">
                                <div class="result-value">99.5%</div>
                                <div class="result-label">Solving time reduction</div>
                                <div class="result-detail">Hardest task: 1hr ‚Üí 17sec</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">22%</div>
                                <div class="result-label">Tasks improved</div>
                                <div class="result-detail">97/449 tasks</div>
                            </div>
                            <div class="result-card">
                                <div class="result-value">29%</div>
                                <div class="result-label">Learning time reduction</div>
                                <div class="result-detail">128/449 tasks faster</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Human Teaching -->
            <div class="content-block paper-deep-dive" data-level="4" id="human-teaching-section">
                <div class="block-header">
                    <h3>Can Humans Teach Machines to Code?</h3>
                    <span class="complexity-badge advanced">Advanced</span>
                </div>
                <div class="block-content">
                    <div class="paper-citation">
                        <span class="citation-authors">Hocquette, Langer, Cropper & Schmid (2025)</span>
                        <span class="citation-venue">arXiv:2404.19397</span>
                    </div>

                    <div class="concept-explanation">
                        <h4>The Key Assumption Under Test</h4>
                        <div class="big-question">
                            <p>
                                Program synthesis assumes humans can provide <strong>sufficient examples</strong> to teach concepts.
                                Is this assumption valid?
                            </p>
                        </div>
                    </div>

                    <!-- Study Design -->
                    <div class="study-overview">
                        <h4>Empirical Study Design</h4>
                        <div class="design-grid">
                            <div class="design-item">
                                <h5>Participants</h5>
                                <ul>
                                    <li><strong>14</strong> Non-Computer Scientists (NCS)</li>
                                    <li><strong>25</strong> Computer Scientists (CS)</li>
                                    <li><strong>1</strong> Expert (program synthesis specialist)</li>
                                </ul>
                            </div>
                            <div class="design-item">
                                <h5>Concepts Taught</h5>
                                <ul>
                                    <li>last (return last element)</li>
                                    <li>length (count elements)</li>
                                    <li>append (add to end)</li>
                                    <li>maxlist (find maximum)</li>
                                    <li>dropk (remove first k)</li>
                                    <li>sorted (check ascending)</li>
                                </ul>
                            </div>
                            <div class="design-item">
                                <h5>Systems Tested</h5>
                                <ul>
                                    <li>POPPER (ILP)</li>
                                    <li>METAGOL (ILP)</li>
                                    <li>ALEPH (ILP)</li>
                                    <li>HL (Bayesian)</li>
                                    <li>DeepSeek-Coder (LLM)</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Key Results -->
                    <div class="accuracy-comparison">
                        <h4>Predictive Accuracy Results</h4>
                        <div class="chart-container">
                            <div class="bar-chart-horizontal">
                                <div class="chart-bar-group">
                                    <span class="bar-label">Expert</span>
                                    <div class="bar-container">
                                        <div class="bar expert" style="width: 100%;">100%</div>
                                    </div>
                                </div>
                                <div class="chart-bar-group">
                                    <span class="bar-label">Random (Uniform)</span>
                                    <div class="bar-container">
                                        <div class="bar random" style="width: 85%;">85%</div>
                                    </div>
                                </div>
                                <div class="chart-bar-group">
                                    <span class="bar-label">NCS Group</span>
                                    <div class="bar-container">
                                        <div class="bar ncs" style="width: 76%;">76%</div>
                                    </div>
                                </div>
                                <div class="chart-bar-group">
                                    <span class="bar-label">CS Group</span>
                                    <div class="bar-container">
                                        <div class="bar cs" style="width: 73%;">73%</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Key Findings -->
                    <div class="finding-cards">
                        <h4>Three Key Research Questions‚ÄîThree Surprising Answers</h4>
                        
                        <div class="finding-card negative">
                            <div class="finding-number">Q1</div>
                            <div class="finding-content">
                                <h5>Do humans provide sufficient examples?</h5>
                                <p class="answer"><strong>NO.</strong> Non-experts generally fail to provide sufficient examples for synthesis systems to learn accurate programs.</p>
                                <p class="evidence">Only 3/25 CS participants achieved 100% accuracy on sorted.</p>
                            </div>
                        </div>

                        <div class="finding-card neutral">
                            <div class="finding-number">Q2</div>
                            <div class="finding-content">
                                <h5>Does CS background help?</h5>
                                <p class="answer"><strong>NO.</strong> Mann-Whitney U-test finds no significant difference between NCS and CS groups.</p>
                                <p class="evidence">Domain knowledge alone doesn't improve teaching ability.</p>
                            </div>
                        </div>

                        <div class="finding-card negative">
                            <div class="finding-number">Q3</div>
                            <div class="finding-content">
                                <h5>Do humans beat random examples?</h5>
                                <p class="answer"><strong>NO.</strong> Random examples significantly outperform human examples (p &lt; 0.05).</p>
                                <p class="evidence">This challenges assumptions in program synthesis research.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Why Humans Fail -->
                    <div class="failure-analysis">
                        <h4>Why Non-Experts Fail</h4>
                        <div class="failure-reasons">
                            <div class="reason-card">
                                <span class="reason-icon">üìè</span>
                                <h5>Simpler Examples</h5>
                                <p>Humans provide shorter lists. Expert uses length 12-14 for maxlist; non-experts rarely exceed length 7.</p>
                                <p class="consequence">Shorter examples allow ambiguous interpretations (e.g., "return 4th element" vs "return last").</p>
                            </div>
                            <div class="reason-card">
                                <span class="reason-icon">üéØ</span>
                                <h5>Low Variability</h5>
                                <p>Non-expert element values cluster around small numbers with low variance.</p>
                                <p class="consequence">Creates coincidental patterns that mislead the learner.</p>
                            </div>
                            <div class="reason-card">
                                <span class="reason-icon">üìä</span>
                                <h5>More ‚â† Better</h5>
                                <p>Non-experts provided MORE examples (6-7 on average) than the expert (2-4).</p>
                                <p class="consequence">Quality of examples matters more than quantity.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Expert Examples -->
                    <div class="expert-examples">
                        <h4>What the Expert Did Differently</h4>
                        <table class="expert-table">
                            <thead>
                                <tr>
                                    <th>Concept</th>
                                    <th>Expert Examples</th>
                                    <th>Strategy</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>last</td>
                                    <td>[72,88,23,92,63,100]‚Üí100, []‚Üínone</td>
                                    <td>Long list + edge case (empty)</td>
                                </tr>
                                <tr>
                                    <td>maxlist</td>
                                    <td>14-element list, 12-element list, []‚Üínone</td>
                                    <td>Varied positions of max + edge case</td>
                                </tr>
                                <tr>
                                    <td>sorted</td>
                                    <td>2 true, 1 false (close to true), []‚Üítrue</td>
                                    <td>Near-miss negative + edge case</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Implications -->
                    <div class="implications-section">
                        <h4>Implications for Program Synthesis Research</h4>
                        <div class="implications-grid">
                            <div class="implication-card">
                                <h5>For System Designers</h5>
                                <p>Cannot assume user-provided examples are sufficient. Need active learning, example guidance, or hybrid approaches.</p>
                            </div>
                            <div class="implication-card">
                                <h5>For HCI Research</h5>
                                <p>Understanding the learner's algorithm may be key‚Äîthe expert knew what examples would disambiguate.</p>
                            </div>
                            <div class="implication-card">
                                <h5>For ML Researchers</h5>
                                <p>Algorithms optimized on random/synthetic data may struggle on human-provided examples. Dataset bias matters.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Research Synthesis -->
            <div class="content-block" data-level="5">
                <div class="block-header">
                    <h3>Research Synthesis: A Unified Vision</h3>
                    <span class="complexity-badge phd">PhD Level</span>
                </div>
                <div class="block-content">
                    <div class="synthesis-overview">
                        <h4>How These Advances Connect</h4>
                        <div class="pipeline-diagram">
                            <div class="pipeline-stage">
                                <div class="stage-box">Input Program / Hypothesis Space</div>
                            </div>
                            <div class="pipeline-arrow">‚Üì</div>
                            <div class="pipeline-stage">
                                <div class="stage-box symmetry">Symmetry Breaking<br><small>Remove equivalent hypotheses</small></div>
                            </div>
                            <div class="pipeline-arrow">‚Üì</div>
                            <div class="pipeline-stage">
                                <div class="stage-box reducer">REDUCER<br><small>Prune pointless rules</small></div>
                            </div>
                            <div class="pipeline-arrow">‚Üì</div>
                            <div class="pipeline-stage">
                                <div class="stage-box refactor">MAXREFACTOR<br><small>Compress learned knowledge</small></div>
                            </div>
                            <div class="pipeline-arrow">‚Üì</div>
                            <div class="pipeline-stage">
                                <div class="stage-box output">Optimal, Compact Hypothesis</div>
                            </div>
                        </div>
                    </div>

                    <div class="combined-impact">
                        <h4>Combined Impact</h4>
                        <div class="impact-stats">
                            <div class="impact-stat">
                                <span class="impact-value">&gt;99%</span>
                                <span class="impact-label">Potential time reduction (REDUCER + Symmetry)</span>
                            </div>
                            <div class="impact-stat">
                                <span class="impact-value">60%</span>
                                <span class="impact-label">Better compression (MAXREFACTOR)</span>
                            </div>
                            <div class="impact-stat">
                                <span class="impact-value">GI-hard</span>
                                <span class="impact-label">Complexity foundations established</span>
                            </div>
                        </div>
                    </div>

                    <div class="future-directions">
                        <h4>Open Questions for Future Research</h4>
                        <div class="questions-grid">
                            <div class="question-card">
                                <span class="question-number">1</span>
                                <p>Can we achieve complete symmetry breaking despite GI-hardness through domain-specific techniques?</p>
                            </div>
                            <div class="question-card">
                                <span class="question-number">2</span>
                                <p>How can we help non-expert users provide better teaching examples through interactive guidance?</p>
                            </div>
                            <div class="question-card">
                                <span class="question-number">3</span>
                                <p>Can REDUCER's pointless rule detection be extended to recursive predicates?</p>
                            </div>
                            <div class="question-card">
                                <span class="question-number">4</span>
                                <p>How do these techniques combine with neural-guided search?</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Full Citations -->
            <div class="content-block" data-level="3">
                <div class="block-header">
                    <h3>Full Citations</h3>
                    <span class="complexity-badge intermediate">Reference</span>
                </div>
                <div class="block-content">
                    <div class="citations-list">
                        <div class="citation-entry">
                            <span class="cite-number">[1]</span>
                            <span class="cite-text">
                                M. Liu, D.M. Cerna, F. Gouveia, and A. Cropper. 
                                <em>"Scalable Knowledge Refactoring using Constrained Optimisation."</em> 
                                arXiv:2408.11530, August 2024.
                            </span>
                        </div>
                        <div class="citation-entry">
                            <span class="cite-number">[2]</span>
                            <span class="cite-text">
                                A. Cropper and D.M. Cerna. 
                                <em>"Efficient Rule Induction by Ignoring Pointless Rules."</em> 
                                arXiv:2502.01232, February 2025.
                            </span>
                        </div>
                        <div class="citation-entry">
                            <span class="cite-number">[3]</span>
                            <span class="cite-text">
                                A. Cropper, D.M. Cerna, and M. J√§rvisalo. 
                                <em>"Symmetry Breaking for Inductive Logic Programming."</em> 
                                arXiv:2508.06263, August 2025.
                            </span>
                        </div>
                        <div class="citation-entry">
                            <span class="cite-number">[4]</span>
                            <span class="cite-text">
                                C. Hocquette, J. Langer, A. Cropper, and U. Schmid. 
                                <em>"Can Humans Teach Machines to Code?"</em> 
                                arXiv:2404.19397, April 2024.
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="footer-content">
            <div class="footer-brand">
                <span class="brand-symbol">Œª</span>
                <span>ILP Explorer</span>
            </div>
            <div class="footer-info">
                <p>An interactive educational platform for Inductive Logic Programming</p>
                <p>PhD Research Context: ELLIS Institute Finland ‚Ä¢ Andrew Cropper's LOL Group</p>
            </div>
            <div class="footer-links">
                <a href="https://www.cs.ox.ac.uk/people/andrew.cropper/" target="_blank">Andrew Cropper</a>
                <a href="https://ellis.eu/" target="_blank">ELLIS</a>
                <a href="https://github.com/logic-and-learning-lab" target="_blank">LOL Lab</a>
            </div>
        </div>
    </footer>

    <script src="app.js"></script>
</body>
</html>
